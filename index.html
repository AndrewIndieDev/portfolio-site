<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andrew Dowsett</title>

    <!-- Favicon -->
    <link rel="icon" type="image/ico" href="favicon.ico">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.andrewdowsett.dev/">
    <meta property="og:title" content="Andrew Dowsett - Game Developer">
    <meta property="og:description" content="Brisbane-based Game Developer">
    <meta property="og:image" content="https://www.andrewdowsett.dev/images/profile-photo.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://www.andrewdowsett.dev/">
    <meta property="twitter:title" content="Andrew Dowsett - Game Developer">
    <meta property="twitter:description" content="Brisbane-based Game Developer">
    <meta property="twitter:image" content="https://www.andrewdowsett.dev/images/profile-photo.png">

    <!-- Preload Achievement Icons -->
    <link rel="preload" as="image" href="images/achievements/first_visit.png">
    <link rel="preload" as="image" href="images/achievements/scroll_end.png">
    <link rel="preload" as="image" href="images/achievements/light_mode.png">
    <link rel="preload" as="image" href="images/achievements/dark_mode.png">
    <link rel="preload" as="image" href="images/achievements/view_all_projects.png">
    <link rel="preload" as="image" href="images/achievements/external_link.png">
    <link rel="preload" as="image" href="images/achievements/time_spent.png">
    <link rel="preload" as="image" href="images/achievements/read_about.png">
    <link rel="preload" as="image" href="images/achievements/hover_master.png">
    <link rel="preload" as="image" href="images/achievements/unlock_all.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
</head>
<body>
    <div class="minimap" id="minimap">
        <div class="minimap-inner">
            <div class="minimap-background"></div>
            <div class="minimap-boundary-left"></div>
            <div class="minimap-boundary-right"></div>
            <div class="minimap-viewport-box" id="minimapViewportBox"></div>
        </div>
        <div class="minimap-time-indicator">
            <img class="time-cycle" id="timeCycle" src="images/time-cycle.png" alt="Time Cycle">
            <div class="time-compass-arrow"></div>
        </div>
    </div>

    <div class="dpad" id="dpad">
        <button class="dpad-btn dpad-btn-up" id="dpadUp" aria-label="D-Pad Up" title="Coming Soon">
            <span class="dpad-arrow">▲</span>
        </button>
        <button class="dpad-btn dpad-btn-left" id="dpadLeft" aria-label="Scroll Left" title="Scroll Left">
            <span class="dpad-arrow">◀</span>
        </button>
        <button class="dpad-btn dpad-btn-right" id="dpadRight" aria-label="Scroll Right" title="Scroll Right">
            <span class="dpad-arrow">▶</span>
        </button>
        <button class="dpad-btn dpad-btn-down" id="dpadDown" aria-label="D-Pad Down" title="Coming Soon">
            <span class="dpad-arrow">▼</span>
        </button>
        <div class="dpad-center"></div>
    </div>

    <div class="controller-buttons" id="controllerButtons">
        <button class="controller-btn controller-btn-north" id="btnNorth" aria-label="Toggle theme" title="Toggle Light/Dark Mode">
            <span class="btn-label">Y</span>
            <span class="theme-badge" id="themeBadge">Light</span>
        </button>
        <button class="controller-btn controller-btn-west" id="btnWest" aria-label="View achievements" title="View Achievements">
            <span class="btn-label">X</span>
            <span class="trophy-count" id="trophyCount">0/10</span>
        </button>
        <button class="controller-btn controller-btn-east" id="btnEast" aria-label="Button East" title="Coming Soon">
            <span class="btn-label">B</span>
        </button>
        <button class="controller-btn controller-btn-south" id="btnSouth" aria-label="Button South" title="Coming Soon">
            <span class="btn-label">A</span>
        </button>
    </div>

    <div class="achievement-modal-overlay" id="achievementModal">
        <div class="achievement-modal">
            <div class="achievement-modal-header">
                <div>
                    <div class="achievement-modal-title">
                        <img class="achievement-modal-trophy" src="images/trophy-icon.svg" alt="Trophy">
                        <span>Achievements</span>
                    </div>
                    <div class="achievement-modal-progress" id="modalProgress">0/10 Unlocked</div>
                </div>
                <button class="achievement-modal-close" id="closeModal" aria-label="Close">×</button>
            </div>
            <div class="achievement-grid" id="achievementGrid">
                <!-- Achievement cards will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div class="dev-console" id="devConsole">
        <div class="dev-console-header">
            <span class="dev-console-title">Unity Dev Console</span>
            <button class="dev-console-close" id="closeConsole" aria-label="Close">×</button>
        </div>
        <div class="dev-console-output" id="consoleOutput">
            <div class="console-message console-system">Developer Console Activated</div>
            <div class="console-message console-system">Type 'help' for available commands</div>
        </div>
        <div class="dev-console-input-container">
            <span class="console-prompt">></span>
            <input type="text" class="dev-console-input" id="consoleInput" placeholder="Enter command..." autocomplete="off">
        </div>
    </div>

    <div class="xp-bar-container" id="xpBarContainer">
        <div class="xp-bar-level">
            <span class="xp-level-text">LVL <span id="xpLevel">1</span></span>
        </div>
        <div class="xp-bar-wrapper">
            <div class="xp-bar-bg">
                <div class="xp-bar-fill" id="xpBarFill"></div>
            </div>
            <div class="xp-bar-text" id="xpBarText">0%</div>
        </div>
    </div>

    <div class="custom-scrollbar" id="customScrollbar">
        <div class="scrollbar-track">
            <div class="scrollbar-thumb" id="scrollbarThumb"></div>
        </div>
    </div>

    <div class="level-up-notification" id="levelUpNotification">
        <div class="level-up-text">LEVEL UP!</div>
        <div class="level-up-level">Level <span id="levelUpNumber">2</span></div>
    </div>

    <canvas class="particle-canvas" id="particleCanvas"></canvas>

    <!-- Boss Widget -->
    <div class="boss-widget" id="bossWidget">
        <div class="boss-online-counter" id="bossOnlineCounter">Online: 1</div>
        <div class="boss-container">
            <div class="boss-body" id="bossBody"></div>
            <div class="boss-head" id="bossHead"></div>
        </div>

        <div class="boss-health-bar-container">
            <div class="boss-health-bar">
                <div class="boss-health-fill" id="bossHealthFill"></div>
                <div class="boss-health-text" id="bossHealthText">10,000 / 10,000</div>
            </div>
            <div class="boss-info">
                <span class="boss-name" id="bossName">The Awakening</span>
                <span class="boss-phase" id="bossPhase">Phase 1</span>
            </div>
        </div>

        <div class="upgrade-hover-text" id="upgradeHoverText">Upgrades</div>

        <div class="upgrade-menu" id="upgradeMenu">
            <button class="upgrade-button upgrade-damage" data-upgrade="damage">
                <img src="images/boss_upgrades/damage.png" alt="Damage" class="upgrade-icon">
            </button>
            <button class="upgrade-button upgrade-speed" data-upgrade="attackspeed">
                <img src="images/boss_upgrades/attackspeed.png" alt="Attack Speed" class="upgrade-icon">
            </button>
            <button class="upgrade-button upgrade-auto" data-upgrade="critchance">
                <img src="images/boss_upgrades/crit_chance.png" alt="Crit Chance" class="upgrade-icon">
            </button>
            <button class="upgrade-button upgrade-crit" data-upgrade="critdamage">
                <img src="images/boss_upgrades/crit_damage.png" alt="Crit Damage" class="upgrade-icon">
            </button>
        </div>

        <div class="upgrade-tooltip" id="upgradeTooltip">
            <div class="tooltip-name" id="tooltipName">Upgrade Name</div>
            <div class="tooltip-level" id="tooltipLevel">Level: 0</div>
            <div class="tooltip-cost" id="tooltipCost">Cost: 100 XP</div>
            <div class="tooltip-effect" id="tooltipEffect">+10 <span class="stat-increase">DPS</span></div>
        </div>
    </div>

    <div class="horizontal-container">
    <section class="intro-container">
        <div class="hello-text">Hello.</div>
        <div class="intro-section">
            <div class="intro-text">
                <p>I'm <span class="name-bold">Andrew Dowsett</span>, a Unity Systems Engineer who loves structuring words to create engaging, interactive experiences.</p>
            </div>
            <div class="intro-image">
                <img src="images/profile-photo.png" alt="">
            </div>
        </div>
        <div class="intro-arrow-image">
            <p class="read-more-text">explore more</p>
            <img src="images/down-arrow.png" alt="" class="arrow-horizontal">
        </div>
    </section>

    <section class="aboutme-section">
        <h2 class="aboutme-title">About Me</h2>
        
        <div class="aboutme-item">
            <div class="aboutme-info">
                <p>I'm a self-taught Unity developer with over 10 years of hands-on experience building games, tools, and systems in the Unity Engine. I specialise in systems programming, rapid prototyping, and creating clean, scalable architectures for small and mid-sized game teams.</p>
                <br>
                <p>Based in Australia, I've spent the past decade refining my skills through shipped projects, prototypes, and continuous self-directed learning.</p>
            </div>
        </div>
    </section>

    <section class="projects-section">
        <h2 class="projects-title">Projects</h2>
        
        <div class="project-item">
            <div class="project-info">
                <h3>Carrot Commotion</h3>
                <h4>Platform:</h4>
                <p>PC (Server) / Mobile + WebGL (Client)</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://store.steampowered.com/app/2914110/Carrot_Commotion/" target="_blank" rel="noopener noreferrer">
                    Steam
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://www.artstation.com/scarlettainsworth" target="_blank" rel="noopener noreferrer">
                    Scarlett Ainsworth
                    </a>
                </p>
                <p>
                    <a href="https://alanamation.carrd.co/" target="_blank" rel="noopener noreferrer">
                    Alana McAnulty
                    </a>
                </p>
                <p>
                    <a href="https://miguelboura.carrd.co/" target="_blank" rel="noopener noreferrer">
                    Miguel Boura
                    </a>
                </p>
                <p><a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                </a></p>
                <br>
                <h4>Description:</h4>
                <p>Carrot Commotion is a social deduction party game with up to 8 frienemies. Choose your favourite character, and receive your box with an item in it. Hide the contents of your box while figuring out what other players have to win the Carrot Cup!</p>
            </div>
            <div class="project-frame"
            data-src="images/Carrot Commotion/Thumbnail.png"
            data-hover="images/Carrot Commotion/Thumbnail.gif">
                <div class="project-frame-banner">Wishlist on Steam</div>
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>Ridiculous Gungame</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://store.steampowered.com/app/1224310/Ridiculous_Gungame/" target="_blank" rel="noopener noreferrer">
                    Steam
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>David Lawrence</p>
                <br>
                <h4>Description:</h4>
                <p>Ridiculous Gungame is an instagib party shooter game with lobbies up to 32 people! Each person can customise their character and enter a customised game with ridiculous weapons to fight with. It's kill or die laughing!</p>
            </div>
            <div class="project-frame"
            data-src="images/Ridiculous Gungame/Thumbnail.png"
            data-hover="images/Ridiculous Gungame/Thumbnail.gif">
                <div class="project-frame-banner">Wishlist on Steam</div>
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>I Have More Hours Than You</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://store.steampowered.com/app/3056640/I_Have_More_Hours_Than_You/" target="_blank" rel="noopener noreferrer">
                    Steam
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>David Lawrence</p>
                <br>
                <h4>Description:</h4>
                <p>I Have More Hours Than You is a idle-like collection game at it's core. You interact with events and progress an abstract story about acceptance using Steam Achievements. This was created to test our knowledge of the Steam API.</p>
            </div>
            <div class="project-frame"
            data-src="images/IHMHTY/Thumbnail.png"
            data-hover="images/IHMHTY/Thumbnail.gif">
                <div class="project-frame-banner">Released</div>
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>One Ships Trash</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://liam3d.itch.io/one-ships-trash-jam" target="_blank" rel="noopener noreferrer">
                    Itch.io
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                    </a>
                </p>
                <p>
                    <a href="https://www.liam-3d.com/" target="_blank" rel="noopener noreferrer">
                    Liam Clarkson-Holborn
                    </a>
                </p>
                <p>Jayden Cosgrove</p>
                <br>
                <h4>Description:</h4>
                <p>Created for the 48 hour Season of the Dev 2025 Game Jam. One Ships Trash is a magnet fishing game about cleaning a Sunshine Coast reef. The reef was created using the Ex-HMAS Brisbane Warship, that was scuttled in July 2005.</p>
            </div>
            <div class="project-frame"
            data-src="images/One Ships Trash/Thumbnail.png"
            data-hover="images/One Ships Trash/Thumbnail.gif">
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>Dino Eco Simulation</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://andrewindie.itch.io/project-gcap" target="_blank" rel="noopener noreferrer">
                    Itch.io
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                    </a>
                </p>
                <br>
                <h4>Description:</h4>
                <p>Created for a self-imposed week-long game jam during MIGW, we wanted to make a game that gives you the feeling of seeing Dinosaurs live their lives. Not shooting them, riding them, or otherwise. Just a relaxing game about placing them in an environment; watching them grow, eat, mate and eventually take thier last breath.</p>
            </div>
            <div class="project-frame"
            data-src="images/Dinosaur Ecosystem/Thumbnail.png"
            data-hover="images/Dinosaur Ecosystem/Thumbnail.gif">
            </div>
        </div>

        <div class="project-item" data-hidden="true">
            <div class="project-info">
                <h3>Mandela Protocol</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>Coming Soon</p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                    </a></p>
                <br>
                <h4>Description:</h4>
                <p>Mandela Protocol is a dangerous spot the difference horror game. Report anomalies to your robot friend using your camera, and hope the anomalies don't come after you. Team up with up to X (TBD) players and report all the anomalies like a good little human.</p>
            </div>
            <div class="project-frame"
            data-src="images/Mandela Protocol/thumbnail.png"
            data-hover="images/Mandela Protocol/thumbnail.png">
                <div class="project-frame-banner">Secret</div>
            </div>
        </div>
    </section>

    </div>

    <script>
        // Achievement System
        const ACHIEVEMENTS = {
            'first_visit': {
                id: 'first_visit',
                title: 'Welcome!',
                description: 'Thanks for visiting my portfolio',
                icon: 'images/achievements/first_visit.png',
                xp: 10
            },
            'scroll_end': {
                id: 'scroll_end',
                title: 'Journey Complete',
                description: 'Reached the end of the room',
                icon: 'images/achievements/scroll_end.png',
                xp: 25
            },
            'light_mode': {
                id: 'light_mode',
                title: 'Enlightened',
                description: 'Switched to light mode',
                icon: 'images/achievements/light_mode.png',
                xp: 15
            },
            'dark_mode': {
                id: 'dark_mode',
                title: 'Shadow Walker',
                description: 'Switched to dark mode',
                icon: 'images/achievements/dark_mode.png',
                xp: 15
            },
            'view_all_projects': {
                id: 'view_all_projects',
                title: 'Completionist',
                description: 'Viewed all non-hidden projects',
                icon: 'images/achievements/view_all_projects.png',
                xp: 30
            },
            'external_link': {
                id: 'external_link',
                title: 'Curious Mind',
                description: 'Clicked on a project link',
                icon: 'images/achievements/external_link.png',
                xp: 20
            },
            'time_spent': {
                id: 'time_spent',
                title: 'Dedicated Visitor',
                description: 'Spent 2 minutes exploring',
                icon: 'images/achievements/time_spent.png',
                xp: 35
            },
            'read_about': {
                id: 'read_about',
                title: 'Getting Personal',
                description: 'Read the About Me section',
                icon: 'images/achievements/read_about.png',
                xp: 20
            },
            'hover_master': {
                id: 'hover_master',
                title: 'Interactive Explorer',
                description: 'Hovered over 3 project previews',
                icon: 'images/achievements/hover_master.png',
                xp: 25
            },
            'unlock_all': {
                id: 'unlock_all',
                title: 'Achievement Hunter',
                description: 'Unlocked all achievements!',
                icon: 'images/achievements/unlock_all.png',
                xp: 50
            }
        };

        // Notification Toast System for general messages (errors, warnings, info)
        class NotificationToast {
            constructor() {
                this.toastQueue = [];
                this.isShowingToast = false;
            }

            show(message, type = 'info') {
                this.toastQueue.push({ message, type });
                if (!this.isShowingToast) {
                    this.processQueue();
                }
            }

            error(message) {
                this.show(message, 'error');
            }

            warning(message) {
                this.show(message, 'warning');
            }

            success(message) {
                this.show(message, 'success');
            }

            info(message) {
                this.show(message, 'info');
            }

            achievement(achievement) {
                this.toastQueue.push({ achievement, type: 'achievement' });
                if (!this.isShowingToast) {
                    this.processQueue();
                }
            }

            processQueue() {
                if (this.toastQueue.length === 0) {
                    this.isShowingToast = false;
                    return;
                }

                this.isShowingToast = true;
                const item = this.toastQueue.shift();

                // Handle achievement toast differently
                if (item.achievement) {
                    this.showAchievementToast(item.achievement);
                } else {
                    this.showRegularToast(item.message, item.type);
                }
            }

            showAchievementToast(achievement) {
                const toast = document.createElement('div');
                toast.className = 'notification-toast notification-achievement';
                toast.innerHTML = `
                    <img class="notification-achievement-icon" src="${achievement.icon}" alt="${achievement.title}" onerror="this.style.display='none'">
                    <div class="notification-content">
                        <div class="notification-title">Achievement Unlocked! +${achievement.xp} XP</div>
                        <div class="notification-message"><strong>${achievement.title}</strong> - ${achievement.description}</div>
                    </div>
                `;

                document.body.appendChild(toast);

                // Show animation
                setTimeout(() => toast.classList.add('show'), 100);

                // Hide and remove after 4 seconds
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        document.body.removeChild(toast);
                        this.processQueue();
                    }, 500);
                }, 4000);
            }

            showRegularToast(message, type) {
                // Add icon based on type
                let icon = '';
                let title = '';
                switch(type) {
                    case 'error':
                        icon = '❌';
                        title = 'Error';
                        break;
                    case 'warning':
                        icon = '⚠️';
                        title = 'Warning';
                        break;
                    case 'success':
                        icon = '✓';
                        title = 'Success';
                        break;
                    case 'info':
                    default:
                        icon = 'ℹ️';
                        title = 'Info';
                        break;
                }

                const toast = document.createElement('div');
                toast.className = `notification-toast notification-${type}`;
                toast.innerHTML = `
                    <div class="notification-icon">${icon}</div>
                    <div class="notification-content">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                `;

                document.body.appendChild(toast);

                // Show animation
                setTimeout(() => toast.classList.add('show'), 100);

                // Hide and remove after 3.5 seconds
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        document.body.removeChild(toast);
                        this.processQueue();
                    }, 500);
                }, 3500);
            }
        }

        // Initialize notification toast system
        const notificationToast = new NotificationToast();

        class AchievementManager {
            constructor() {
                this.unlockedAchievements = this.loadProgress();
                this.projectsViewed = new Set();
                this.projectsHovered = new Set();
                this.startTime = Date.now();
                this.hasViewedAbout = false;
                this.aboutMeTimer = null;

                this.init();
            }

            init() {
                this.updateTrophyCount();
                this.setupEventListeners();

                // Check first visit
                setTimeout(() => {
                    this.unlock('first_visit');
                }, 1000);

                // Check time spent
                setTimeout(() => {
                    this.unlock('time_spent');
                }, 120000); // 2 minutes
            }

            loadProgress() {
                const saved = localStorage.getItem('portfolio_achievements');
                return saved ? JSON.parse(saved) : [];
            }

            saveProgress() {
                localStorage.setItem('portfolio_achievements', JSON.stringify(this.unlockedAchievements));
            }

            unlock(achievementId) {
                if (this.unlockedAchievements.includes(achievementId)) {
                    return;
                }

                this.unlockedAchievements.push(achievementId);
                this.saveProgress();
                const achievement = ACHIEVEMENTS[achievementId];
                notificationToast.achievement(achievement);
                this.updateTrophyCount();

                // Grant XP to boss widget (syncs to Firebase)
                if (achievement.xp && window.bossWidget) {
                    window.bossWidget.addAchievementXP(achievement.xp);
                }

                // Check if all achievements unlocked
                if (this.unlockedAchievements.length === Object.keys(ACHIEVEMENTS).length - 1) {
                    setTimeout(() => this.unlock('unlock_all'), 500);
                }
            }

            updateTrophyCount() {
                const count = this.unlockedAchievements.length;
                const total = Object.keys(ACHIEVEMENTS).length;
                document.getElementById('trophyCount').textContent = `${count}/${total}`;
            }

            setupEventListeners() {
                // Scroll detection (horizontal)
                window.addEventListener('scroll', () => {
                    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                    const windowWidth = window.innerWidth;
                    const documentWidth = document.documentElement.scrollWidth;

                    // Check if scrolled to the end
                    if (scrollLeft + windowWidth >= documentWidth - 100) {
                        this.unlock('scroll_end');
                    }

                    // Check if About Me section is in view
                    const aboutSection = document.querySelector('.aboutme-section');
                    if (aboutSection && !this.hasViewedAbout) {
                        const rect = aboutSection.getBoundingClientRect();
                        const isInView = rect.left < windowWidth && rect.right > 0;

                        if (isInView) {
                            // Start timer if not already started
                            if (!this.aboutMeTimer) {
                                this.aboutMeTimer = setTimeout(() => {
                                    this.unlock('read_about');
                                    this.hasViewedAbout = true;
                                }, 5000); // 5 seconds
                            }
                        } else {
                            // Cancel timer if user scrolled away
                            if (this.aboutMeTimer) {
                                clearTimeout(this.aboutMeTimer);
                                this.aboutMeTimer = null;
                            }
                        }
                    }

                    // Track which projects are in view (excluding hidden ones)
                    const projectFrames = document.querySelectorAll('.project-item:not([data-hidden="true"])');
                    projectFrames.forEach((project, index) => {
                        const rect = project.getBoundingClientRect();
                        if (rect.left < windowWidth && rect.right > 0) {
                            this.projectsViewed.add(index);
                            if (this.projectsViewed.size === projectFrames.length) {
                                this.unlock('view_all_projects');
                            }
                        }
                    });
                });

                // External link clicks
                document.querySelectorAll('.project-info a').forEach(link => {
                    link.addEventListener('click', () => {
                        this.unlock('external_link');
                    });
                });

                // Project hover tracking (excluding hidden projects)
                document.querySelectorAll('.project-item:not([data-hidden="true"]) .project-frame').forEach((frame, index) => {
                    frame.addEventListener('mouseenter', () => {
                        this.projectsHovered.add(index);
                        if (this.projectsHovered.size >= 3) {
                            this.unlock('hover_master');
                        }
                    });
                });

                // West button click - show all achievements
                document.getElementById('btnWest').addEventListener('click', () => {
                    this.showAchievementList();
                });
            }

            showAchievementList() {
                const modal = document.getElementById('achievementModal');
                const grid = document.getElementById('achievementGrid');
                const progress = document.getElementById('modalProgress');

                // Update progress text
                const total = Object.keys(ACHIEVEMENTS).length;
                const count = this.unlockedAchievements.length;
                progress.textContent = `${count}/${total} Unlocked`;

                // Clear and populate grid
                grid.innerHTML = '';
                Object.values(ACHIEVEMENTS).forEach(ach => {
                    const unlocked = this.unlockedAchievements.includes(ach.id);
                    const card = document.createElement('div');
                    card.className = `achievement-card ${unlocked ? 'unlocked' : 'locked'}`;
                    card.innerHTML = `
                        <img class="achievement-card-icon" src="${ach.icon}" alt="${ach.title}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2264%22 height=%2264%22%3E%3Crect width=%2264%22 height=%2264%22 fill=%22%23666%22 rx=%228%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 font-size=%2224%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22%3E%3F%3C/text%3E%3C/svg%3E'">
                        <div class="achievement-card-content">
                            <div class="achievement-card-title">
                                ${ach.title}
                            </div>
                            <div class="achievement-card-description">${ach.description}</div>
                        </div>
                    `;
                    grid.appendChild(card);
                });

                // Show modal
                modal.classList.add('show');
            }

            hideAchievementList() {
                const modal = document.getElementById('achievementModal');
                modal.classList.remove('show');
            }
        }

        // Initialize achievement system
        window.achievementManager = new AchievementManager();

        // Modal close functionality
        document.getElementById('closeModal').addEventListener('click', () => {
            achievementManager.hideAchievementList();
        });

        // Close modal when clicking outside
        document.getElementById('achievementModal').addEventListener('click', (e) => {
            if (e.target.id === 'achievementModal') {
                achievementManager.hideAchievementList();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                achievementManager.hideAchievementList();
            }
        });

        // Dev Console System
        class DevConsole {
            constructor() {
                this.console = document.getElementById('devConsole');
                this.output = document.getElementById('consoleOutput');
                this.input = document.getElementById('consoleInput');
                this.isActive = false;
                this.konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
                this.konamiIndex = 0;
                this.hiddenProjectsVisible = false;

                this.commands = {
                    'help': () => this.showHelp(),
                    'ad_testtoast': () => this.testToast(),
                    'ad_showhiddenprojects': () => this.showHiddenProjects(),
                    'clear': () => this.clearOutput(),
                    'close': () => this.toggle()
                };

                this.init();
            }

            init() {
                // Konami code detection
                document.addEventListener('keydown', (e) => {
                    if (e.key === this.konamiCode[this.konamiIndex]) {
                        this.konamiIndex++;
                        if (this.konamiIndex === this.konamiCode.length) {
                            this.activate();
                            this.konamiIndex = 0;
                        }
                    } else {
                        this.konamiIndex = 0;
                    }
                });

                // Console input handling
                this.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const command = this.input.value.trim();
                        if (command) {
                            this.executeCommand(command);
                            this.input.value = '';
                        }
                    }
                });

                // Close button
                document.getElementById('closeConsole').addEventListener('click', () => {
                    this.toggle();
                });

                // Focus input when console opens
                this.console.addEventListener('transitionend', () => {
                    if (this.isActive) {
                        this.input.focus();
                    }
                });
            }

            activate() {
                this.addMessage('Konami Code Activated! Developer Console Unlocked.', 'success');
                this.toggle();
            }

            toggle() {
                this.isActive = !this.isActive;
                this.console.classList.toggle('active');
                if (this.isActive) {
                    setTimeout(() => this.input.focus(), 300);
                }
            }

            executeCommand(command) {
                this.addMessage(`> ${command}`, 'command');

                const cmd = command.toLowerCase().trim();
                if (this.commands[cmd]) {
                    this.commands[cmd]();
                } else {
                    this.addMessage(`Unknown command: "${command}". Type 'help' for available commands.`, 'error');
                }

                // Auto-scroll to bottom
                this.output.scrollTop = this.output.scrollHeight;
            }

            addMessage(text, type = 'info') {
                const msg = document.createElement('div');
                msg.className = `console-message console-${type}`;
                msg.textContent = text;
                this.output.appendChild(msg);
                this.output.scrollTop = this.output.scrollHeight;
            }

            showHelp() {
                this.addMessage('Available Commands:', 'info');
                this.addMessage('  help - Show this help message', 'info');
                this.addMessage('  ad_testtoast - Test achievement toast notification', 'info');
                this.addMessage('  ad_showhiddenprojects - Toggle hidden projects visibility', 'info');
                this.addMessage('  clear - Clear console output', 'info');
                this.addMessage('  close - Close the console', 'info');
            }

            testToast() {
                const testAchievement = {
                    id: 'test',
                    title: 'Test Achievement',
                    description: 'This is a test notification from the dev console',
                    icon: 'images/achievements/placeholder.svg',
                    xp: 25
                };
                notificationToast.achievement(testAchievement);
                this.addMessage('Test toast notification triggered.', 'success');
            }

            showHiddenProjects() {
                this.hiddenProjectsVisible = !this.hiddenProjectsVisible;
                const hiddenProjects = document.querySelectorAll('.project-item[data-hidden="true"]');

                hiddenProjects.forEach(project => {
                    if (this.hiddenProjectsVisible) {
                        project.style.display = 'grid';
                    } else {
                        project.style.display = 'none';
                    }
                });

                if (hiddenProjects.length === 0) {
                    this.addMessage('No hidden projects found.', 'warning');
                } else {
                    const state = this.hiddenProjectsVisible ? 'shown' : 'hidden';
                    this.addMessage(`Hidden projects ${state} (${hiddenProjects.length} project${hiddenProjects.length > 1 ? 's' : ''}).`, 'success');
                }
            }

            clearOutput() {
                this.output.innerHTML = '';
                this.addMessage('Console cleared.', 'system');
            }
        }

        // Initialize dev console
        const devConsole = new DevConsole();

        // XP System
        class XPSystem {
            constructor() {
                this.xpBarFill = document.getElementById('xpBarFill');
                this.xpBarText = document.getElementById('xpBarText');
                this.xpLevel = document.getElementById('xpLevel');
                this.levelUpNotification = document.getElementById('levelUpNotification');
                this.levelUpNumber = document.getElementById('levelUpNumber');
                this.canvas = document.getElementById('particleCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.currentLevel = 1;
                this.currentXP = 0;
                this.particles = [];

                this.loadProgress();
                this.setupCanvas();
                this.init();
            }

            init() {
                window.addEventListener('resize', () => this.setupCanvas());
                this.updateDisplay();
                this.animate();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            // Exponential XP requirements: level 1 = 50 XP, each level requires 1.5x more
            getXPForLevel(level) {
                return Math.floor(50 * Math.pow(1.5, level - 1));
            }

            // Sync XP from boss widget's totalXP
            syncFromBossWidget() {
                if (!window.bossWidget) return;

                const totalXP = window.bossWidget.totalXP || 0;

                // Calculate level and current XP from total earned XP
                let tempLevel = 1;
                let remainingXP = totalXP;

                // Process level ups (consume XP for each level gained)
                while (remainingXP >= this.getXPForLevel(tempLevel)) {
                    remainingXP -= this.getXPForLevel(tempLevel);
                    tempLevel++;
                }

                // Check if we leveled up
                const oldLevel = this.currentLevel;
                this.currentLevel = tempLevel;
                this.currentXP = remainingXP;

                if (this.currentLevel > oldLevel) {
                    this.levelUp();
                }

                this.updateDisplay();
            }

            loadProgress() {
                // Wait for boss widget to initialize, then sync
                const checkBossWidget = setInterval(() => {
                    if (window.bossWidget && window.bossWidget.playerData) {
                        this.syncFromBossWidget();
                        clearInterval(checkBossWidget);
                    }
                }, 100);

                // Timeout after 5 seconds if boss widget doesn't load
                setTimeout(() => clearInterval(checkBossWidget), 5000);
            }

            saveProgress() {
                // No longer saving XP - it's synced from boss widget
            }

            addXP(amount) {
                // Deprecated - XP now managed by boss widget
            }

            updateDisplay() {
                const xpNeeded = this.getXPForLevel(this.currentLevel);
                const progress = (this.currentXP / xpNeeded) * 100;

                this.xpBarFill.style.width = progress + '%';
                this.xpBarText.textContent = `${this.currentXP}/${xpNeeded}`;
                this.xpLevel.textContent = this.currentLevel;
            }

            levelUp() {
                // Show level up notification
                this.levelUpNumber.textContent = this.currentLevel;
                this.levelUpNotification.classList.add('show');

                // Create particles
                this.createLevelUpParticles();

                // Hide notification after 2 seconds
                setTimeout(() => {
                    this.levelUpNotification.classList.remove('show');
                }, 2000);
            }

            createLevelUpParticles() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const particleCount = 50;

                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const velocity = 2 + Math.random() * 3;

                    this.particles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * velocity,
                        vy: Math.sin(angle) * velocity,
                        life: 1,
                        decay: 0.015 + Math.random() * 0.01,
                        size: 3 + Math.random() * 4,
                        color: this.getRandomColor()
                    });
                }
            }

            getRandomColor() {
                const colors = ['#FFB014', '#FFC04D', '#FFD700', '#FFA500'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Update and draw particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    // Update particle
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; // Gravity
                    p.life -= p.decay;

                    // Remove dead particles
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }

                    // Draw particle
                    this.ctx.save();
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }

                requestAnimationFrame(() => this.animate());
            }
        }

        // Mobile detection utility
        function isMobileDevice() {
            // Check for mobile device based on screen width and user agent
            const mobileWidth = window.innerWidth <= 768;
            const mobileUserAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            return mobileWidth || mobileUserAgent;
        }

        // Initialize XP system (desktop only - requires boss widget)
        if (!isMobileDevice()) {
            window.xpSystem = new XPSystem();
        }

        // Minimap System
        class MinimapSystem {
            constructor() {
                this.minimap = document.getElementById('minimap');
                this.viewportBox = document.getElementById('minimapViewportBox');
                this.leftBoundary = document.querySelector('.minimap-boundary-left');
                this.timeCycle = document.getElementById('timeCycle');
                this.init();
            }

            init() {
                // Update time rotation
                this.updateTimeRotation();
                setInterval(() => this.updateTimeRotation(), 60000); // Update every minute

                // Update viewport box position on scroll
                window.addEventListener('scroll', () => this.updateViewportPosition());
                window.addEventListener('resize', () => this.updateViewportPosition());
                this.updateViewportPosition();

                // Add click handler for minimap navigation
                this.minimap.addEventListener('click', (e) => this.handleMinimapClick(e));
                this.minimap.style.cursor = 'pointer';
            }

            handleMinimapClick(e) {
                // Get click position relative to minimap
                const rect = this.minimap.getBoundingClientRect();
                const clickX = e.clientX - rect.left;

                // Get dimensions and boundaries (same as updateViewportPosition)
                const minimapWidth = this.minimap.offsetWidth;
                const viewportBoxWidth = this.viewportBox.offsetWidth;
                const leftBoundaryPos = this.leftBoundary.offsetLeft;
                const rightBoundaryOffset = 5;
                const boundaryWidth = 2;
                const leftGap = 4;
                const rightGap = 6;

                // Calculate travel range
                const minLeft = leftBoundaryPos + leftGap;
                const maxLeft = minimapWidth - rightBoundaryOffset - boundaryWidth - rightGap - viewportBoxWidth;
                const travelRange = maxLeft - minLeft;

                // Calculate scroll percentage from click position
                // Center the viewport box on the click position
                const targetBoxLeft = clickX - (viewportBoxWidth / 2);
                const clampedBoxLeft = Math.max(minLeft, Math.min(maxLeft, targetBoxLeft));
                const scrollPercentage = (clampedBoxLeft - minLeft) / travelRange;

                // Calculate target scroll position
                const maxScrollX = document.documentElement.scrollWidth - window.innerWidth;
                const targetScrollX = scrollPercentage * maxScrollX;

                // Smooth scroll to position
                window.scrollTo({
                    left: targetScrollX,
                    behavior: 'smooth'
                });
            }

            updateTimeRotation() {
                const now = new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const totalMinutes = hours * 60 + minutes;

                // Adjust so 6am is 0deg (start of day), 6pm is 180deg (start of night)
                const adjustedMinutes = (totalMinutes - 360 + 1440) % 1440; // Subtract 6am (360 min) and wrap
                const rotation = (adjustedMinutes / 1440) * 360;

                // Rotate counter-clockwise (negate the rotation)
                this.timeCycle.style.transform = `rotate(-${rotation}deg)`;
            }

            updateViewportPosition() {
                const scrollPercentage = window.scrollX / (document.documentElement.scrollWidth - window.innerWidth);

                // Get actual dimensions from DOM for responsive support
                const minimapWidth = this.minimap.offsetWidth;
                const viewportBoxWidth = this.viewportBox.offsetWidth;
                const leftBoundaryPos = this.leftBoundary.offsetLeft; // Read from DOM for responsiveness
                const rightBoundaryOffset = 5; // Right boundary from right edge
                const boundaryWidth = 2; // Boundary line width
                const leftGap = 4; // Gap on left side between viewport box and left boundary
                const rightGap = 6; // Gap on right side between viewport box and right boundary

                // Calculate travel range with asymmetric gaps (4px left, 6px right)
                // Left: boundary position + 4px gap
                // Right: boundary at (width - 5 - 2), box right edge stops 6px before at (width - 5 - 2 - 6)
                //        so box left position is (width - 13 - boxWidth)
                const minLeft = leftBoundaryPos + leftGap;
                const maxLeft = minimapWidth - rightBoundaryOffset - boundaryWidth - rightGap - viewportBoxWidth;
                const travelRange = maxLeft - minLeft;

                // Calculate left position based on scroll percentage
                const leftPosition = minLeft + (scrollPercentage * travelRange);

                this.viewportBox.style.left = `${leftPosition}px`;
            }
        }

        // Initialize minimap
        const minimapSystem = new MinimapSystem();

        // Horizontal Scroll System - Convert vertical wheel to horizontal scroll
        window.addEventListener('wheel', (e) => {
            // Prevent default vertical scroll
            if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                e.preventDefault();
                // Convert vertical scroll to horizontal
                window.scrollBy({
                    left: e.deltaY,
                    behavior: 'auto'
                });
            }
        }, { passive: false });

        // Mobile touch scroll - disable vertical, enable horizontal
        let touchStartY = 0;
        let touchStartX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            const touchDeltaY = Math.abs(e.touches[0].clientY - touchStartY);
            const touchDeltaX = Math.abs(e.touches[0].clientX - touchStartX);

            // If vertical movement is greater than horizontal, prevent it
            if (touchDeltaY > touchDeltaX) {
                e.preventDefault();
            }
        }, { passive: false });

        // Custom Scrollbar System
        function updateCustomScrollbar() {
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollWidth = document.documentElement.scrollWidth - window.innerWidth;
            const scrollPercentage = (scrollLeft / scrollWidth) * 100;

            const scrollbarThumb = document.getElementById('scrollbarThumb');
            if (scrollbarThumb) {
                scrollbarThumb.style.width = scrollPercentage + '%';
            }
        }

        window.addEventListener('scroll', updateCustomScrollbar);
        window.addEventListener('resize', updateCustomScrollbar);
        updateCustomScrollbar();

        // Controller buttons functionality
        const btnNorth = document.getElementById('btnNorth');
        const themeBadge = document.getElementById('themeBadge');
        const body = document.body;

        // Function to update theme badge
        function updateThemeBadge() {
            if (body.classList.contains('light-mode')) {
                themeBadge.textContent = 'Dark';
            } else {
                themeBadge.textContent = 'Light';
            }
        }

        // Initialize theme badge
        updateThemeBadge();

        // North button - Theme toggle
        btnNorth.addEventListener('click', () => {
            body.classList.toggle('light-mode');
            updateThemeBadge();

            if (body.classList.contains('light-mode')) {
                achievementManager.unlock('light_mode');
            } else {
                achievementManager.unlock('dark_mode');
            }
        });

        // D-Pad functionality - dispatch keyboard events for Konami code
        function dispatchKeyEvent(key) {
            const event = new KeyboardEvent('keydown', {
                key: key,
                code: key,
                bubbles: true,
                cancelable: true
            });
            document.dispatchEvent(event);
        }

        document.getElementById('dpadUp').addEventListener('click', () => {
            dispatchKeyEvent('ArrowUp');
        });

        document.getElementById('dpadDown').addEventListener('click', () => {
            dispatchKeyEvent('ArrowDown');
        });

        // D-pad left/right continuous scroll when held down
        let scrollInterval = null;
        const scrollSpeed = 20; // Interval in milliseconds (faster = smoother)
        const scrollAmount = 8; // Pixels per interval tick (20ms * 8px = 400px/second)

        function startContinuousScroll(direction) {
            // Clear any existing interval
            if (scrollInterval) {
                clearInterval(scrollInterval);
            }

            // Immediate first scroll
            window.scrollBy({
                left: direction === 'left' ? -scrollAmount : scrollAmount,
                behavior: 'auto' // Use auto for continuous scrolling
            });

            // Start continuous scrolling
            scrollInterval = setInterval(() => {
                window.scrollBy({
                    left: direction === 'left' ? -scrollAmount : scrollAmount,
                    behavior: 'auto'
                });
            }, scrollSpeed);
        }

        function stopContinuousScroll() {
            if (scrollInterval) {
                clearInterval(scrollInterval);
                scrollInterval = null;
            }
        }

        // Left button continuous scroll
        const dpadLeft = document.getElementById('dpadLeft');
        dpadLeft.addEventListener('mousedown', () => startContinuousScroll('left'));
        dpadLeft.addEventListener('mouseup', stopContinuousScroll);
        dpadLeft.addEventListener('mouseleave', stopContinuousScroll);
        dpadLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startContinuousScroll('left');
        });
        dpadLeft.addEventListener('touchend', stopContinuousScroll);
        dpadLeft.addEventListener('touchcancel', stopContinuousScroll);

        // Right button continuous scroll
        const dpadRight = document.getElementById('dpadRight');
        dpadRight.addEventListener('mousedown', () => startContinuousScroll('right'));
        dpadRight.addEventListener('mouseup', stopContinuousScroll);
        dpadRight.addEventListener('mouseleave', stopContinuousScroll);
        dpadRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startContinuousScroll('right');
        });
        dpadRight.addEventListener('touchend', stopContinuousScroll);
        dpadRight.addEventListener('touchcancel', stopContinuousScroll);

        // Keep click handlers for Konami code compatibility
        document.getElementById('dpadLeft').addEventListener('click', () => {
            dispatchKeyEvent('ArrowLeft');
        });

        document.getElementById('dpadRight').addEventListener('click', () => {
            dispatchKeyEvent('ArrowRight');
        });

        // East button (B) and South button (A) - dispatch keyboard events
        document.getElementById('btnEast').addEventListener('click', () => {
            dispatchKeyEvent('b');
        });

        document.getElementById('btnSouth').addEventListener('click', () => {
            dispatchKeyEvent('a');
        });

        // Keyboard arrow key scrolling with held-down support
        let keyScrollInterval = null;
        let currentScrollKey = null;

        document.addEventListener('keydown', (e) => {
            // Don't scroll if user is typing in the dev console
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // Only respond to real keyboard events, not dispatched events from D-pad clicks
            if (!e.isTrusted) {
                return;
            }

            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();

                // If already scrolling with this key, don't start again
                if (currentScrollKey === e.key) {
                    return;
                }

                // Stop any existing scroll
                if (keyScrollInterval) {
                    clearInterval(keyScrollInterval);
                }

                currentScrollKey = e.key;
                const direction = e.key === 'ArrowLeft' ? -1 : 1;
                const keyScrollAmount = 8; // Pixels per interval tick (20ms * 8px = 400px/second)

                // Immediate first scroll
                window.scrollBy({
                    left: direction * keyScrollAmount,
                    behavior: 'auto'
                });

                // Start continuous scrolling
                keyScrollInterval = setInterval(() => {
                    window.scrollBy({
                        left: direction * keyScrollAmount,
                        behavior: 'auto'
                    });
                }, 20);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (keyScrollInterval) {
                    clearInterval(keyScrollInterval);
                    keyScrollInterval = null;
                    currentScrollKey = null;
                }
            }
        });

        // Stop all scrolling if window loses focus
        window.addEventListener('blur', () => {
            stopContinuousScroll();
            if (keyScrollInterval) {
                clearInterval(keyScrollInterval);
                keyScrollInterval = null;
                currentScrollKey = null;
            }
        });

        // Initialize project frames with static images
        const projectFrames = document.querySelectorAll('.project-frame');
        
        projectFrames.forEach(frame => {
            frame.style.backgroundImage = `url('${frame.dataset.src}')`;
        });

        // Auto-play GIF for project closest to center
        let currentActiveFrame = null;
        let changeTimeout = null;

        function updateActiveProject() {
            const viewportCenter = window.innerWidth / 2;
            let closestFrame = null;
            let smallestDistance = Infinity;

            projectFrames.forEach(frame => {
                if (!frame.dataset.hover) return; // Skip if no GIF available

                const rect = frame.getBoundingClientRect();
                const frameCenter = rect.left + rect.width / 2;
                const distance = Math.abs(frameCenter - viewportCenter);

                if (distance < smallestDistance) {
                    smallestDistance = distance;
                    closestFrame = frame;
                }
            });

            // Update frames with 1 second delay
            if (closestFrame !== currentActiveFrame) {
                // Clear any pending change
                if (changeTimeout) {
                    clearTimeout(changeTimeout);
                }

                // Wait 1 second before changing
                changeTimeout = setTimeout(() => {
                    // Stop previous GIF
                    if (currentActiveFrame && currentActiveFrame.dataset.hover) {
                        currentActiveFrame.style.backgroundImage = `url('${currentActiveFrame.dataset.src}')`;
                    }

                    // Play new GIF
                    if (closestFrame && closestFrame.dataset.hover) {
                        closestFrame.style.backgroundImage = `url('${closestFrame.dataset.hover}')`;
                    }

                    currentActiveFrame = closestFrame;
                }, 500);
            }
        }

        // Throttle scroll events for better performance
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            if (scrollTimeout) {
                window.cancelAnimationFrame(scrollTimeout);
            }
            scrollTimeout = window.requestAnimationFrame(() => {
                updateActiveProject();
            });
        });

        // Initial check
        updateActiveProject();

        // Manual hover still works
        projectFrames.forEach(frame => {
            frame.addEventListener('mouseenter', () => {
                if(frame.dataset.hover) {
                    frame.style.backgroundImage = `url('${frame.dataset.hover}')`;
                }
            });

            frame.addEventListener('mouseleave', () => {
                // Only reset if this frame is not the currently active one
                if (frame !== currentActiveFrame) {
                    frame.style.backgroundImage = `url('${frame.dataset.src}')`;
                }
            });
        });

        // ===========================
        //      BOSS WIDGET SYSTEM
        // ===========================

        class BossWidget {
            constructor() {
                // Firebase configuration
                this.firebaseConfig = {
                    apiKey: "AIzaSyABduDmw6F50DZ2gFPhyQV_qlzGKaVT7mw",
                    authDomain: "portfolio-boss-raid.firebaseapp.com",
                    projectId: "portfolio-boss-raid",
                    storageBucket: "portfolio-boss-raid.firebasestorage.app",
                    messagingSenderId: "431982597085",
                    appId: "1:431982597085:web:622b13cf3b8b8a1a565c34"
                };

                // DOM elements
                this.widget = document.getElementById('bossWidget');
                this.bossBody = document.getElementById('bossBody');
                this.bossHead = document.getElementById('bossHead');
                this.healthFill = document.getElementById('bossHealthFill');
                this.healthText = document.getElementById('bossHealthText');
                this.bossName = document.getElementById('bossName');
                this.phaseText = document.getElementById('bossPhase');
                this.upgradeMenu = document.getElementById('upgradeMenu');
                this.upgradeTooltip = document.getElementById('upgradeTooltip');
                this.onlineCounter = document.getElementById('bossOnlineCounter');

                // State
                this.currentPhase = 1;
                this.bossState = null;
                this.playerData = null;
                this.bossData = {}; // Store boss data (names, etc.) by phase
                this.isMenuOpen = false;
                this.lastDamageTime = Date.now();
                this.lastLocalDamageTime = Date.now();
                this.targetHealth = 100;
                this.currentDisplayHealth = 100;
                this.animationFrame = null;
                this.localDamageAccumulated = 0;
                this.localBossHealth = 0; // Client-side boss health for immediate feedback
                this.lastHitAnimationTime = 0; // Track when we last played hit animation
                this.trackingCursor = false; // Track whether tooltip should follow cursor
                this.totalXP = 0; // Optimistic XP for display (synced from server every 5min)

                // Firestore listener unsubscribe functions
                this.bossListener = null;
                this.onlineListener = null;

                // Upgrade definitions
                this.upgrades = {
                    damage: {
                        name: 'Damage',
                        icon: 'images/boss_upgrades/damage.png',
                        baseCost: 2,
                        costMultiplier: 2.0,
                        getEffect: (level) => {
                            const totalDamage = 1 + (level * 2);
                            return `${totalDamage}`;
                        },
                        description: 'Damage'
                        // No maxLevel - unlimited
                    },
                    attackspeed: {
                        name: 'Attack Speed',
                        icon: 'images/boss_upgrades/attackspeed.png',
                        baseCost: 128,
                        costMultiplier: 2.0,
                        maxLevel: 20,
                        getEffect: (level) => {
                            const interval = 2000 * Math.pow(0.9, level);
                            const seconds = (interval / 1000).toFixed(2);
                            return `${seconds}s`;
                        },
                        description: 'Attack Speed'
                    },
                    critchance: {
                        name: 'Crit Chance',
                        icon: 'images/boss_upgrades/crit_chance.png',
                        baseCost: 2,
                        costMultiplier: 2.0,
                        maxLevel: 30,
                        getEffect: (level) => `${level * 2}%`,
                        description: 'Crit Chance'
                    },
                    critdamage: {
                        name: 'Crit Damage',
                        icon: 'images/boss_upgrades/crit_damage.png',
                        baseCost: 2,
                        costMultiplier: 2.0,
                        maxLevel: 30,
                        getEffect: (level) => `+${100 + level * 10}%`,
                        description: 'Crit Damage'
                    }
                };

                this.init();
            }

            async init() {
                try {
                    // Check if Firebase SDK is loaded via CDN
                    if (typeof firebase === 'undefined') {
                        this.useMockData();
                        return;
                    }

                    // Initialize Firebase
                    if (!firebase.apps.length) {
                        firebase.initializeApp(this.firebaseConfig);
                    }

                    this.auth = firebase.auth();
                    this.db = firebase.firestore();

                    // Get Functions instance for australia-southeast1 region
                    const app = firebase.app();
                    this.functions = app.functions('australia-southeast1');
                    // this.functions.useEmulator('localhost', 5001); // Disabled for production

                    // Sign in anonymously and wait for auth state to be ready
                    await this.auth.signInAnonymously();

                    // Wait a moment for auth token to propagate
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Create player
                    await this.createPlayer();

                    // Load data and start systems
                    await this.loadData();

                    this.setupEventListeners();
                    this.startLocalDamageLoop(); // Apply damage locally every 100ms
                    this.startDamageLoop(); // Sync with server every 5 minutes
                    this.startHealthAnimation();
                    this.listenToBossChanges();
                    this.listenToOnlineCount();

                } catch (error) {
                    this.useMockData();
                }
            }

            calculateBossHP(phase) {
                if (phase <= 100) {
                    // Exponential growth from 10,000 (phase 1) to 1,000,000,000 (phase 100)
                    const baseHP = 10000;
                    const multiplier = Math.pow(100000, 1/99); // ≈ 1.1174
                    return Math.floor(baseHP * Math.pow(multiplier, phase - 1));
                } else {
                    // Linear growth: 1 billion HP per level after phase 100
                    return 1000000000 * (phase - 99);
                }
            }

            formatNumber(num) {
                // Format large numbers with abbreviations
                const absNum = Math.abs(num);

                if (absNum >= 1000000000) {
                    // Billions (1.00b)
                    return (num / 1000000000).toFixed(2) + 'b';
                } else if (absNum >= 1000000) {
                    // Millions (1.00m)
                    return (num / 1000000).toFixed(2) + 'm';
                } else if (absNum >= 1000) {
                    // Thousands (1.00k)
                    return (num / 1000).toFixed(2) + 'k';
                } else {
                    // Less than 1000, show as integer
                    return Math.floor(num).toString();
                }
            }

            useMockData() {
                // Mock data for testing without Firebase
                this.bossState = {
                    currentHealth: 10000,
                    maxHealth: 10000,
                    phase: 1
                };
                this.playerData = {
                    xp: 0,
                    totalXP: 0,
                    dps: 1,
                    upgrades: { damage: 0, attackspeed: 0, critchance: 0, critdamage: 0 },
                    totalDamage: 0
                };

                // Initialize local boss health and total XP
                this.localBossHealth = this.bossState.currentHealth;
                this.lastLocalDamageTime = Date.now();
                this.totalXP = 0;

                this.updateUI();
                this.setupEventListeners();
                this.startLocalDamageLoop(); // Apply damage locally every 100ms
                this.startMockDamage(); // "Sync" with mock server every 5 minutes
                this.startHealthAnimation();
            }

            async createPlayer() {
                const createPlayerFunc = this.functions.httpsCallable('createPlayer');
                const result = await createPlayerFunc();
                return result;
            }

            async loadData() {
                const uid = this.auth.currentUser.uid;

                // Load player data
                const playerDoc = await this.db.collection('players').doc(uid).get();
                this.playerData = playerDoc.data();

                // Initialize totalXP if not present
                if (!this.playerData.totalXP) {
                    this.playerData.totalXP = 0;
                }
                this.totalXP = this.playerData.totalXP;

                // Load upgrades from subcollection
                this.playerData.upgrades = {};
                const upgradesSnapshot = await this.db.collection('players').doc(uid).collection('upgrades').get();
                upgradesSnapshot.forEach(doc => {
                    this.playerData.upgrades[doc.id] = doc.data().level || 0;
                });

                // Load boss state
                const bossDoc = await this.db.collection('boss').doc('state').get();
                this.bossState = bossDoc.data();

                // Initialize local boss health from server
                this.localBossHealth = this.bossState.currentHealth;

                this.lastDamageTime = Date.now();
                this.lastLocalDamageTime = Date.now();
                this.updateUI();
            }

            listenToBossChanges() {
                // Unsubscribe from previous listener if it exists
                if (this.bossListener) {
                    this.bossListener();
                }

                // Real-time listener for boss state changes (from other players)
                this.bossListener = this.db.collection('boss').doc('state').onSnapshot((doc) => {
                    const previousHealth = this.bossState.currentHealth;
                    this.bossState = doc.data();

                    // Check if boss HP dropped from server update (other players' damage)
                    if (previousHealth && this.bossState.currentHealth < previousHealth) {
                        // Trigger blue swipe to indicate other players' damage
                        this.createServerSwipeVFX();
                    }

                    // Update local health to match server (other players may have damaged it)
                    this.localBossHealth = this.bossState.currentHealth;
                    this.updateUI();
                });
            }

            listenToOnlineCount() {
                // Unsubscribe from previous listener if it exists
                if (this.onlineListener) {
                    this.onlineListener();
                }

                // Real-time listener for online player count
                this.onlineListener = this.db.collection('stats').doc('online').onSnapshot((doc) => {
                    if (doc.exists) {
                        const data = doc.data();
                        const count = data.count || 0;
                        this.onlineCounter.textContent = `Online: ${count}`;
                    }
                });
            }

            getAttackInterval() {
                // Base attack interval is 2000ms (2 seconds)
                let baseInterval = 2000;
                const upgrades = this.playerData.upgrades || {};
                const attackSpeedLevel = upgrades['attackspeed'] || 0;

                // Each level reduces interval by 10% (multiplicative)
                // Formula: baseInterval * (0.9 ^ attackSpeedLevel)
                const interval = baseInterval * Math.pow(0.9, attackSpeedLevel);

                return interval;
            }

            getBaseDamage() {
                let baseDamage = this.playerData.dps || 1;
                const upgrades = this.playerData.upgrades || {};
                const damageLevel = upgrades['damage'] || 0;

                // Add flat damage from damage upgrades
                baseDamage += damageLevel * 2;

                return baseDamage;
            }

            getCritChance() {
                const upgrades = this.playerData.upgrades || {};
                const critChanceLevel = upgrades['critchance'] || 0;

                // 2% crit chance per level
                return critChanceLevel * 2;
            }

            getCritMultiplier() {
                const upgrades = this.playerData.upgrades || {};
                const critDamageLevel = upgrades['critdamage'] || 0;

                // Base 100% + 10% per level (so level 1 = 110%, level 2 = 120%, etc.)
                return 1.0 + (critDamageLevel * 0.1);
            }

            calculateDPS() {
                // Calculate average DPS including crit chance
                const baseDamage = this.getBaseDamage();
                const critChance = this.getCritChance() / 100; // Convert to decimal
                const critMultiplier = this.getCritMultiplier();
                const attackInterval = this.getAttackInterval();

                // Average damage per hit = baseDamage × (1 + critMultiplier × critChance)
                // This accounts for: non-crits do baseDamage, crits do baseDamage × (1 + critMultiplier)
                const avgDamagePerHit = baseDamage * (1 + critMultiplier * critChance);

                // DPS = average damage per hit / attack interval in seconds
                const dps = avgDamagePerHit / (attackInterval / 1000);

                return dps;
            }

            startLocalDamageLoop() {
                // Apply damage locally for smooth visual feedback
                setInterval(() => {
                    const now = Date.now();

                    // Check for client-side boss "death" (just for visual feedback)
                    if (this.localBossHealth <= 0) {
                        this.localBossHealth = 0;
                    }

                    // Play hit animation based on attack speed
                    const attackInterval = this.getAttackInterval();
                    if (now - this.lastHitAnimationTime >= attackInterval) {
                        this.showHitAnimation();
                        this.lastHitAnimationTime = now;
                    }

                    // Update UI with local health
                    this.updateLocalUI();
                }, 100); // Update local damage every 100ms for smooth animation
            }

            startDamageLoop() {
                // Sync with server every 5 minutes
                setInterval(async () => {
                    const now = Date.now();
                    const windowStart = this.lastDamageTime;
                    const windowEnd = now;
                    const dps = this.calculateDPS();
                    const damage = dps * ((windowEnd - windowStart) / 1000);

                    try {
                        const submitDamageFunc = this.functions.httpsCallable('submitDamage');
                        const result = await submitDamageFunc({
                            damage,
                            windowStart,
                            windowEnd
                            // Server now calculates XP based on DPS and time
                        });

                        // Reset tracking variables
                        this.lastDamageTime = now;
                        this.localDamageAccumulated = 0;

                        // Update totalXP from server response
                        if (result.data && result.data.newTotalXP !== undefined) {
                            this.playerData.totalXP = result.data.newTotalXP;
                            this.totalXP = result.data.newTotalXP;
                        }

                        // Fetch fresh boss state (includes damage from other players)
                        const bossDoc = await this.db.collection('boss').doc('state').get();
                        this.bossState = bossDoc.data();
                        this.localBossHealth = this.bossState.currentHealth;

                        // Update XP system display
                        if (window.xpSystem) {
                            window.xpSystem.syncFromBossWidget();
                        }

                        this.updateUI();
                        // Don't play hit animation here - it's already playing from local damage loop
                    } catch (error) {
                        // Silent error handling
                    }
                }, 300000); // Sync with server every 5 minutes
            }

            startMockDamage() {
                // Simulate server sync every 5 minutes in mock mode
                setInterval(() => {
                    const dps = this.calculateDPS();
                    const damage = dps * 300; // 5 minutes worth of damage (300 seconds)

                    // Update mock "server" boss state
                    this.bossState.currentHealth -= damage;
                    if (this.bossState.currentHealth <= 0) {
                        // Boss defeated - advance to next phase
                        this.bossState.phase++;
                        this.bossState.maxHealth = this.calculateBossHP(this.bossState.phase);
                        this.bossState.currentHealth = this.bossState.maxHealth;
                    }

                    // Sync local health with "server" health
                    this.localBossHealth = this.bossState.currentHealth;

                    // In mock mode, simulate XP calculation (server would do this)
                    const timeElapsed = 300000; // 5 minutes
                    const xpEarned = Math.floor((dps * (timeElapsed / 1000)) * 0.5);
                    this.playerData.totalXP = (this.playerData.totalXP || 0) + xpEarned;
                    this.totalXP = this.playerData.totalXP;

                    // Update XP system display
                    if (window.xpSystem) {
                        window.xpSystem.syncFromBossWidget();
                    }

                    this.updateUI();
                    // Don't play hit animation here - it's already playing from local damage loop
                }, 300000); // Submit damage every 5 minutes
            }

            updateLocalUI() {
                // Update health bar based on LOCAL boss health for immediate feedback
                const healthPercent = (this.localBossHealth / this.bossState.maxHealth) * 100;
                this.targetHealth = Math.max(0, healthPercent);
            }

            async updateUI() {
                // Update phase
                const phase = this.bossState.phase || 1;
                this.currentPhase = phase;
                this.phaseText.textContent = `Phase ${phase}`;

                // Load and display boss name
                await this.loadBossData(phase);

                // Update boss images
                this.updateBossImages(phase);

                // Update health (smoothly animated via startHealthAnimation)
                const healthPercent = (this.localBossHealth / this.bossState.maxHealth) * 100;
                this.targetHealth = Math.max(0, healthPercent);
            }

            async loadBossData(phase) {
                // Check if we already have the data cached
                if (this.bossData[phase]) {
                    this.bossName.textContent = this.bossData[phase].name;
                    return;
                }

                // Load boss data from JSON file
                try {
                    const response = await fetch(`images/boss/phase_${phase}/boss_data.json`);
                    const data = await response.json();
                    this.bossData[phase] = data;
                    this.bossName.textContent = data.name;
                } catch (error) {
                    this.bossName.textContent = 'Unknown Boss';
                }
            }

            updateBossImages(phase) {
                // Use actual images with new folder structure
                this.bossBody.style.backgroundImage = `url('images/boss/phase_${phase}/body.png')`;
                this.bossHead.style.backgroundImage = `url('images/boss/phase_${phase}/head.png')`;

                // Store current phase for hit animation
                this.currentPhase = phase;
            }

            startHealthAnimation() {
                const animate = () => {
                    // Smoothly interpolate current display health towards target health
                    const diff = this.targetHealth - this.currentDisplayHealth;
                    if (Math.abs(diff) > 0.1) {
                        this.currentDisplayHealth += diff * 0.1;
                    } else {
                        this.currentDisplayHealth = this.targetHealth;
                    }

                    // Update health bar
                    this.healthFill.style.width = `${this.currentDisplayHealth}%`;

                    // Calculate and display actual HP numbers
                    const maxHP = this.bossState.maxHealth;
                    const currentHP = (this.currentDisplayHealth / 100) * maxHP;
                    this.healthText.textContent = `${this.formatNumber(currentHP)} / ${this.formatNumber(maxHP)}`;

                    // Update head position to follow body center
                    this.updateHeadPosition();

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            updateHeadPosition() {
                // Get the body's bounding box to find its current center point
                const bodyRect = this.bossBody.getBoundingClientRect();
                const containerRect = this.bossBody.parentElement.getBoundingClientRect();

                // Calculate center point of body relative to container
                const bodyCenterX = (bodyRect.left + bodyRect.width / 2) - containerRect.left;
                const bodyCenterY = (bodyRect.top + bodyRect.height / 2) - containerRect.top;

                // Position head at body's center point
                this.bossHead.style.left = `${bodyCenterX}px`;
                this.bossHead.style.top = `${bodyCenterY}px`;
                this.bossHead.style.transform = 'translate(-50%, -50%)';
            }

            showHitAnimation() {
                // Calculate damage for this hit (visual only - server calculates authoritative damage)
                const baseDamage = this.getBaseDamage();
                const critChance = this.getCritChance();
                const critMultiplier = this.getCritMultiplier();

                // Roll for crit
                const isCrit = Math.random() * 100 < critChance;
                // Crit damage = base + (base × critMultiplier)
                const damage = isCrit ? baseDamage * (1 + critMultiplier) : baseDamage;

                // Apply damage to boss (visual only)
                this.localBossHealth -= damage;
                this.localDamageAccumulated += damage;
                this.lastLocalDamageTime = Date.now();

                // Calculate OPTIMISTIC XP for display (server calculates true XP)
                // This is just for visual feedback - server will sync the real value
                const xpGain = Math.max(1, Math.floor(damage * 0.5));

                // Track XP locally for display and client-side validation
                this.totalXP += xpGain;
                if (!this.playerData.totalXP) this.playerData.totalXP = 0;
                this.playerData.totalXP += xpGain;

                // Update XP system display
                if (window.xpSystem) {
                    window.xpSystem.syncFromBossWidget();
                }

                this.bossHead.classList.add('hit');

                // Switch to hit image
                this.bossHead.style.backgroundImage = `url('images/boss/phase_${this.currentPhase}/head_hit.png')`;

                // Create swipe VFX (with crit effect if critical hit)
                this.createSwipeVFX(isCrit);

                // Show XP gain text
                this.showXPGainText(xpGain);

                setTimeout(() => {
                    this.bossHead.classList.remove('hit');
                    // Switch back to normal head image
                    this.bossHead.style.backgroundImage = `url('images/boss/phase_${this.currentPhase}/head.png')`;
                }, 300);
            }

            showXPGainText(xpAmount) {
                // Create XP text element
                const xpText = document.createElement('div');
                xpText.className = 'boss-xp-text';
                xpText.textContent = `+${xpAmount} XP`;

                // Append to boss body
                this.bossBody.appendChild(xpText);

                // Remove after animation completes
                setTimeout(() => {
                    xpText.remove();
                }, 1000);
            }

            createSwipeVFX(isCrit = false) {
                // Create normal swipe effect element
                const swipe = document.createElement('div');
                swipe.className = 'boss-swipe-vfx';

                // Apply random rotation between -60 and 60 degrees
                const randomRotation = Math.random() * 120 - 60;
                swipe.style.transform = `translate(-50%, -50%) rotate(${randomRotation}deg)`;

                this.bossHead.appendChild(swipe);

                // Remove after animation completes
                setTimeout(() => {
                    swipe.remove();
                }, 200);

                // If critical hit, add a second red crit swipe with 0.1s delay
                if (isCrit) {
                    setTimeout(() => {
                        const critSwipe = document.createElement('div');
                        critSwipe.className = 'boss-swipe-vfx-crit';

                        // Apply different random rotation for variety
                        const critRotation = Math.random() * 120 - 60;
                        critSwipe.style.transform = `translate(-50%, -50%) rotate(${critRotation}deg)`;

                        this.bossHead.appendChild(critSwipe);

                        // Remove after animation completes
                        setTimeout(() => {
                            critSwipe.remove();
                        }, 200);

                        // Show CRIT text
                        const critText = document.createElement('div');
                        critText.className = 'boss-crit-text';
                        critText.textContent = 'CRIT!';
                        this.bossHead.appendChild(critText);

                        // Remove crit text after animation completes
                        setTimeout(() => {
                            critText.remove();
                        }, 500);
                    }, 100);
                }
            }

            createServerSwipeVFX() {
                // Create blue swipe effect for server updates (other players' damage)
                const swipe = document.createElement('div');
                swipe.className = 'boss-swipe-vfx-server';

                // Apply random rotation between -60 and 60 degrees
                const randomRotation = Math.random() * 120 - 60;
                swipe.style.transform = `translate(-50%, -50%) rotate(${randomRotation}deg)`;

                this.bossHead.appendChild(swipe);

                // Remove after animation completes
                setTimeout(() => {
                    swipe.remove();
                }, 200);
            }

            setupEventListeners() {
                // Click widget to toggle upgrade menu
                this.widget.addEventListener('click', (e) => {
                    if (!e.target.closest('.upgrade-button') && !e.target.closest('.upgrade-menu')) {
                        this.toggleUpgradeMenu();
                    }
                });

                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.boss-widget') && this.isMenuOpen) {
                        this.closeUpgradeMenu();
                    }
                });

                // Track cursor position for tooltip
                document.addEventListener('mousemove', (e) => {
                    if (this.trackingCursor && this.upgradeTooltip.classList.contains('show')) {
                        // Position tooltip near cursor with offset
                        const offsetX = 20;
                        const offsetY = 20;
                        this.upgradeTooltip.style.left = `${e.clientX + offsetX}px`;
                        this.upgradeTooltip.style.top = `${e.clientY + offsetY}px`;
                    }
                });

                // Upgrade button interactions
                const upgradeButtons = document.querySelectorAll('.upgrade-button');
                upgradeButtons.forEach(button => {
                    const upgradeType = button.dataset.upgrade;

                    button.addEventListener('mouseenter', () => {
                        this.showUpgradeTooltip(upgradeType, button);
                    });

                    button.addEventListener('mouseleave', () => {
                        this.hideUpgradeTooltip();
                    });

                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.purchaseUpgrade(upgradeType);
                    });
                });
            }

            toggleUpgradeMenu() {
                this.isMenuOpen = !this.isMenuOpen;
                if (this.isMenuOpen) {
                    this.upgradeMenu.classList.add('show');
                } else {
                    this.upgradeMenu.classList.remove('show');
                    this.hideUpgradeTooltip();
                }
            }

            closeUpgradeMenu() {
                this.isMenuOpen = false;
                this.upgradeMenu.classList.remove('show');
                this.hideUpgradeTooltip();
            }

            showUpgradeTooltip(upgradeType, button) {
                if (!this.isMenuOpen) return;

                const upgrade = this.upgrades[upgradeType];
                const currentLevel = (this.playerData.upgrades && this.playerData.upgrades[upgradeType]) || 0;
                const currentTotalXP = this.playerData.totalXP || 0;

                // Check if upgrade is at max level
                const isMaxed = upgrade.maxLevel && currentLevel >= upgrade.maxLevel;

                document.getElementById('tooltipName').textContent = upgrade.name;

                if (isMaxed) {
                    document.getElementById('tooltipLevel').textContent = `Level: ${currentLevel} (MAX)`;
                    document.getElementById('tooltipCost').textContent = `MAX LEVEL REACHED`;
                    const currentEffect = upgrade.getEffect(currentLevel);
                    document.getElementById('tooltipEffect').innerHTML = `<span class="stat-increase">${currentEffect}</span>`;
                } else {
                    const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, currentLevel));
                    const currentEffect = upgrade.getEffect(currentLevel);
                    const nextEffect = upgrade.getEffect(currentLevel + 1);

                    const levelText = upgrade.maxLevel
                        ? `Level: ${currentLevel}/${upgrade.maxLevel}`
                        : `Level: ${currentLevel}`;
                    document.getElementById('tooltipLevel').textContent = levelText;
                    document.getElementById('tooltipCost').textContent = `Cost: ${cost} Total XP (Have: ${currentTotalXP})`;
                    document.getElementById('tooltipEffect').innerHTML = `<span class="stat-increase">${currentEffect} >> ${nextEffect}</span>`;
                }

                this.upgradeTooltip.classList.add('show');

                // Start tracking cursor position
                this.trackingCursor = true;
            }

            hideUpgradeTooltip() {
                this.upgradeTooltip.classList.remove('show');
                this.trackingCursor = false;
            }

            async addAchievementXP(xpAmount) {
                // Update locally first for immediate feedback
                this.totalXP += xpAmount;
                if (!this.playerData.totalXP) this.playerData.totalXP = 0;
                this.playerData.totalXP += xpAmount;

                // Notify XP system to update display
                if (window.xpSystem) {
                    window.xpSystem.syncFromBossWidget();
                }

                // Sync to Firebase via Cloud Function
                if (this.auth && this.functions) {
                    try {
                        const grantXPFunc = this.functions.httpsCallable('grantAchievementXP');
                        const result = await grantXPFunc({ xpAmount });

                        // Update with server value to stay in sync
                        this.playerData.totalXP = result.data.newTotalXP;
                        this.totalXP = result.data.newTotalXP;
                    } catch (error) {
                        // Silent error handling
                    }
                }
            }

            async purchaseUpgrade(upgradeType) {
                const upgrade = this.upgrades[upgradeType];
                const currentLevel = (this.playerData.upgrades && this.playerData.upgrades[upgradeType]) || 0;

                // Check if upgrade is at max level
                if (upgrade.maxLevel && currentLevel >= upgrade.maxLevel) {
                    notificationToast.warning(`${upgrade.name} is already at MAX level (${upgrade.maxLevel})!`);
                    return;
                }

                const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, currentLevel));

                // Client-side validation to prevent spam requests
                // Check local XP first (server will do authoritative check)
                const localXP = this.playerData.totalXP || 0;
                if (localXP < cost) {
                    notificationToast.error(`Not enough Total XP! Need ${cost}, have ${localXP}`);
                    return;
                }

                // Call Cloud Function to purchase upgrade
                if (this.auth && this.functions) {
                    try {
                        // Server will calculate earned XP and validate purchase
                        const purchaseUpgradeFunc = this.functions.httpsCallable('purchaseUpgrade');
                        const result = await purchaseUpgradeFunc({ upgradeType });

                        // Update locally from server response
                        if (!this.playerData.upgrades) this.playerData.upgrades = {};
                        this.playerData.upgrades[upgradeType] = currentLevel + 1;
                        this.playerData.totalXP = result.data.newTotalXP;
                        this.totalXP = result.data.newTotalXP;

                        // Update XP system display
                        if (window.xpSystem) {
                            window.xpSystem.syncFromBossWidget();
                        }
                    } catch (error) {
                        notificationToast.error('Failed to purchase upgrade: ' + error.message);
                        return;
                    }
                } else {
                    // Mock mode - update locally only
                    const currentTotalXP = this.playerData.totalXP || 0;
                    if (currentTotalXP < cost) {
                        notificationToast.error(`Not enough Total XP! Need ${cost}, have ${currentTotalXP}`);
                        return;
                    }

                    if (!this.playerData.upgrades) this.playerData.upgrades = {};
                    this.playerData.upgrades[upgradeType] = currentLevel + 1;
                    this.playerData.totalXP -= cost;
                    this.totalXP = this.playerData.totalXP;

                    // Update XP system display
                    if (window.xpSystem) {
                        window.xpSystem.syncFromBossWidget();
                    }
                }

                // Refresh tooltip
                const button = document.querySelector(`[data-upgrade="${upgradeType}"]`);
                this.showUpgradeTooltip(upgradeType, button);
            }

            cleanup() {
                // Unsubscribe from all Firestore listeners
                if (this.bossListener) {
                    this.bossListener();
                    this.bossListener = null;
                }
                if (this.onlineListener) {
                    this.onlineListener();
                    this.onlineListener = null;
                }
            }
        }

        // Initialize Boss Widget (desktop only)
        // Note: Requires Firebase SDK to be loaded via CDN in HTML <head>
        if (!isMobileDevice()) {
            window.bossWidget = new BossWidget();

            // Cleanup listeners when page unloads
            window.addEventListener('beforeunload', () => {
                if (window.bossWidget) {
                    window.bossWidget.cleanup();
                }
            });
        }
    </script>
</body>
</html>