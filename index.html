<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andrew Dowsett</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="minimap" id="minimap">
        <div class="minimap-inner">
            <div class="minimap-background"></div>
            <div class="minimap-boundary-left"></div>
            <div class="minimap-boundary-right"></div>
            <div class="minimap-viewport-box" id="minimapViewportBox"></div>
        </div>
        <div class="minimap-time-indicator">
            <img class="time-cycle" id="timeCycle" src="images/time-cycle.png" alt="Time Cycle">
            <div class="time-compass-arrow"></div>
        </div>
    </div>

    <div class="dpad" id="dpad">
        <button class="dpad-btn dpad-btn-up" id="dpadUp" aria-label="D-Pad Up" title="Coming Soon">
            <span class="dpad-arrow">▲</span>
        </button>
        <button class="dpad-btn dpad-btn-left" id="dpadLeft" aria-label="Scroll Left" title="Scroll Left">
            <span class="dpad-arrow">◀</span>
        </button>
        <button class="dpad-btn dpad-btn-right" id="dpadRight" aria-label="Scroll Right" title="Scroll Right">
            <span class="dpad-arrow">▶</span>
        </button>
        <button class="dpad-btn dpad-btn-down" id="dpadDown" aria-label="D-Pad Down" title="Coming Soon">
            <span class="dpad-arrow">▼</span>
        </button>
        <div class="dpad-center"></div>
    </div>

    <div class="controller-buttons" id="controllerButtons">
        <button class="controller-btn controller-btn-north" id="btnNorth" aria-label="Toggle theme" title="Toggle Light/Dark Mode">
            <span class="btn-label">Y</span>
            <span class="theme-badge" id="themeBadge">Light</span>
        </button>
        <button class="controller-btn controller-btn-west" id="btnWest" aria-label="View achievements" title="View Achievements">
            <span class="btn-label">X</span>
            <span class="trophy-count" id="trophyCount">0/10</span>
        </button>
        <button class="controller-btn controller-btn-east" id="btnEast" aria-label="Button East" title="Coming Soon">
            <span class="btn-label">B</span>
        </button>
        <button class="controller-btn controller-btn-south" id="btnSouth" aria-label="Button South" title="Coming Soon">
            <span class="btn-label">A</span>
        </button>
    </div>

    <div class="achievement-modal-overlay" id="achievementModal">
        <div class="achievement-modal">
            <div class="achievement-modal-header">
                <div>
                    <div class="achievement-modal-title">
                        <img class="achievement-modal-trophy" src="images/trophy-icon.svg" alt="Trophy">
                        <span>Achievements</span>
                    </div>
                    <div class="achievement-modal-progress" id="modalProgress">0/10 Unlocked</div>
                </div>
                <button class="achievement-modal-close" id="closeModal" aria-label="Close">×</button>
            </div>
            <div class="achievement-grid" id="achievementGrid">
                <!-- Achievement cards will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div class="dev-console" id="devConsole">
        <div class="dev-console-header">
            <span class="dev-console-title">Unity Dev Console</span>
            <button class="dev-console-close" id="closeConsole" aria-label="Close">×</button>
        </div>
        <div class="dev-console-output" id="consoleOutput">
            <div class="console-message console-system">Developer Console Activated</div>
            <div class="console-message console-system">Type 'help' for available commands</div>
        </div>
        <div class="dev-console-input-container">
            <span class="console-prompt">></span>
            <input type="text" class="dev-console-input" id="consoleInput" placeholder="Enter command..." autocomplete="off">
        </div>
    </div>

    <div class="xp-bar-container" id="xpBarContainer">
        <div class="xp-bar-level">
            <span class="xp-level-text">LVL <span id="xpLevel">1</span></span>
        </div>
        <div class="xp-bar-wrapper">
            <div class="xp-bar-bg">
                <div class="xp-bar-fill" id="xpBarFill"></div>
            </div>
            <div class="xp-bar-text" id="xpBarText">0%</div>
        </div>
    </div>

    <div class="custom-scrollbar" id="customScrollbar">
        <div class="scrollbar-track">
            <div class="scrollbar-thumb" id="scrollbarThumb"></div>
        </div>
    </div>

    <div class="level-up-notification" id="levelUpNotification">
        <div class="level-up-text">LEVEL UP!</div>
        <div class="level-up-level">Level <span id="levelUpNumber">2</span></div>
    </div>

    <canvas class="particle-canvas" id="particleCanvas"></canvas>

    <div class="horizontal-container">
    <section class="intro-container">
        <div class="hello-text">Hello.</div>
        <div class="intro-section">
            <div class="intro-text">
                <p>I'm <span class="name-bold">Andrew Dowsett</span>, a Unity Systems Engineer who loves structuring words to create engaging, interactive experiences.</p>
            </div>
            <div class="intro-image">
                <img src="images/profile-photo.png" alt="">
            </div>
        </div>
        <div class="intro-arrow-image">
            <p class="read-more-text">explore more</p>
            <img src="images/down-arrow.png" alt="" class="arrow-horizontal">
        </div>
    </section>

    <section class="aboutme-section">
        <h2 class="aboutme-title">About Me</h2>
        
        <div class="aboutme-item">
            <div class="aboutme-info">
                <p>I'm a self-taught Unity developer with over 10 years of hands-on experience building games, tools, and systems in the Unity engine. I specialise in gameplay programming, rapid prototyping, and creating clean, scalable architectures for small and mid-sized game teams.</p>
                <br>
                <p>Based in Australia, I've spent the past decade refining my skills through shipped projects, prototypes, and continuous self-directed learning.</p>
            </div>
        </div>
    </section>

    <section class="projects-section">
        <h2 class="projects-title">Projects</h2>
        
        <div class="project-item">
            <div class="project-info">
                <h3>Carrot Commotion</h3>
                <h4>Platform:</h4>
                <p>PC (Server) / Mobile + WebGL (Client)</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://store.steampowered.com/app/2914110/Carrot_Commotion/" target="_blank" rel="noopener noreferrer">
                    Steam
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://www.artstation.com/scarlettainsworth" target="_blank" rel="noopener noreferrer">
                    Scarlett Ainsworth
                    </a>
                </p>
                <p>
                    <a href="https://alanamation.carrd.co/" target="_blank" rel="noopener noreferrer">
                    Alana McAnulty
                    </a>
                </p>
                <p>
                    <a href="https://miguelboura.carrd.co/" target="_blank" rel="noopener noreferrer">
                    Miguel Boura
                    </a>
                </p>
                <p><a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                </a></p>
                <br>
                <h4>Description:</h4>
                <p>Carrot Commotion is a social deduction party game with up to 8 frienemies. Choose your favourite character, and receive your box with an item in it. Hide the contents of your box while figuring out what other players have to win the Carrot Cup!</p>
            </div>
            <div class="project-frame"
            data-src="images/Carrot Commotion/Thumbnail.png"
            data-hover="images/Carrot Commotion/Thumbnail.gif">
                <div class="project-frame-banner">Wishlist on Steam</div>
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>Ridiculous Gungame</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://store.steampowered.com/app/1224310/Ridiculous_Gungame/" target="_blank" rel="noopener noreferrer">
                    Steam
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>David Lawrence</p>
                <br>
                <h4>Description:</h4>
                <p>Ridiculous Gungame is an instagib party shooter game with lobbies up to 32 people! Each person can customise their character and enter a customised game with ridiculous weapons to fight with. It's kill or die laughing!</p>
            </div>
            <div class="project-frame"
            data-src="images/Ridiculous Gungame/Thumbnail.png"
            data-hover="images/Ridiculous Gungame/Thumbnail.gif">
                <div class="project-frame-banner">Wishlist on Steam</div>
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>I Have More Hours Than You</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://store.steampowered.com/app/3056640/I_Have_More_Hours_Than_You/" target="_blank" rel="noopener noreferrer">
                    Steam
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>David Lawrence</p>
                <br>
                <h4>Description:</h4>
                <p>I Have More Hours Than You is a idle-like collection game at it's core. You interact with events and progress an abstract story about acceptance using Steam Achievements. This was created to test our knowledge of the Steam API.</p>
            </div>
            <div class="project-frame"
            data-src="images/IHMHTY/Thumbnail.png"
            data-hover="images/IHMHTY/Thumbnail.gif">
                <div class="project-frame-banner">Released</div>
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>One Ships Trash</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://liam3d.itch.io/one-ships-trash-jam" target="_blank" rel="noopener noreferrer">
                    Itch.io
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                    </a>
                </p>
                <p>
                    <a href="https://www.liam-3d.com/" target="_blank" rel="noopener noreferrer">
                    Liam Clarkson-Holborn
                    </a>
                </p>
                <p>Jayden Cosgrove</p>
                <br>
                <h4>Description:</h4>
                <p>Created for the 48 hour Season of the Dev 2025 Game Jam. One Ships Trash is a magnet fishing game about cleaning a Sunshine Coast reef. The reef was created using the Ex-HMAS Brisbane Warship, that was scuttled in July 2005.</p>
            </div>
            <div class="project-frame"
            data-src="images/One Ships Trash/Thumbnail.png"
            data-hover="images/One Ships Trash/Thumbnail.gif">
            </div>
        </div>

        <div class="project-item">
            <div class="project-info">
                <h3>Dino Eco Simulation</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>
                    <a href="https://andrewindie.itch.io/project-gcap" target="_blank" rel="noopener noreferrer">
                    Itch.io
                    </a>
                </p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                    </a>
                </p>
                <br>
                <h4>Description:</h4>
                <p>Created for a self-imposed week-long game jam during MIGW, we wanted to make a game that gives you the feeling of seeing Dinosaurs live their lives. Not shooting them, riding them, or otherwise. Just a relaxing game about placing them in an environment; watching them grow, eat, mate and eventually take thier last breath.</p>
            </div>
            <div class="project-frame"
            data-src="images/Dinosaur Ecosystem/Thumbnail.png"
            data-hover="images/Dinosaur Ecosystem/Thumbnail.gif">
            </div>
        </div>

        <div class="project-item" data-hidden="true">
            <div class="project-info">
                <h3>Mandela Protocol</h3>
                <h4>Platform:</h4>
                <p>PC</p>
                <br>
                <h4>Store Page:</h4>
                <p>Coming Soon</p>
                <br>
                <h4>Team:</h4>
                <p>Andrew Dowsett</p>
                <p>
                    <a href="https://coreyhorne.com/" target="_blank" rel="noopener noreferrer">
                    Corey Horne
                    </a></p>
                <br>
                <h4>Description:</h4>
                <p>Mandela Protocol is a dangerous spot the difference horror game. Report anomalies to your robot friend using your camera, and hope the anomalies don't come after you. Team up with up to X (TBD) players and report all the anomalies like a good little human.</p>
            </div>
            <div class="project-frame"
            data-src="images/Mandela Protocol/thumbnail.png"
            data-hover="images/Mandela Protocol/thumbnail.png">
                <div class="project-frame-banner">Secret</div>
            </div>
        </div>
    </section>

    </div>

    <script>
        // Achievement System
        const ACHIEVEMENTS = {
            'first_visit': {
                id: 'first_visit',
                title: 'Welcome!',
                description: 'Thanks for visiting my portfolio',
                icon: 'images/achievements/first_visit.png',
                xp: 10
            },
            'scroll_end': {
                id: 'scroll_end',
                title: 'Journey Complete',
                description: 'Reached the end of the room',
                icon: 'images/achievements/scroll_end.png',
                xp: 25
            },
            'light_mode': {
                id: 'light_mode',
                title: 'Enlightened',
                description: 'Switched to light mode',
                icon: 'images/achievements/light_mode.png',
                xp: 15
            },
            'dark_mode': {
                id: 'dark_mode',
                title: 'Shadow Walker',
                description: 'Switched to dark mode',
                icon: 'images/achievements/dark_mode.png',
                xp: 15
            },
            'view_all_projects': {
                id: 'view_all_projects',
                title: 'Completionist',
                description: 'Viewed all non-hidden projects',
                icon: 'images/achievements/view_all_projects.png',
                xp: 30
            },
            'external_link': {
                id: 'external_link',
                title: 'Curious Mind',
                description: 'Clicked on a project link',
                icon: 'images/achievements/external_link.png',
                xp: 20
            },
            'time_spent': {
                id: 'time_spent',
                title: 'Dedicated Visitor',
                description: 'Spent 2 minutes exploring',
                icon: 'images/achievements/time_spent.png',
                xp: 35
            },
            'read_about': {
                id: 'read_about',
                title: 'Getting Personal',
                description: 'Read the About Me section',
                icon: 'images/achievements/read_about.png',
                xp: 20
            },
            'hover_master': {
                id: 'hover_master',
                title: 'Interactive Explorer',
                description: 'Hovered over 3 project previews',
                icon: 'images/achievements/hover_master.png',
                xp: 25
            },
            'unlock_all': {
                id: 'unlock_all',
                title: 'Achievement Hunter',
                description: 'Unlocked all achievements!',
                icon: 'images/achievements/unlock_all.png',
                xp: 50
            }
        };

        class AchievementManager {
            constructor() {
                this.unlockedAchievements = this.loadProgress();
                this.toastQueue = [];
                this.isShowingToast = false;
                this.projectsViewed = new Set();
                this.projectsHovered = new Set();
                this.startTime = Date.now();
                this.hasViewedAbout = false;
                this.aboutMeTimer = null;

                this.init();
            }

            init() {
                this.updateTrophyCount();
                this.setupEventListeners();

                // Check first visit
                setTimeout(() => {
                    this.unlock('first_visit');
                }, 1000);

                // Check time spent
                setTimeout(() => {
                    this.unlock('time_spent');
                }, 120000); // 2 minutes
            }

            loadProgress() {
                const saved = localStorage.getItem('portfolio_achievements');
                return saved ? JSON.parse(saved) : [];
            }

            saveProgress() {
                localStorage.setItem('portfolio_achievements', JSON.stringify(this.unlockedAchievements));
            }

            unlock(achievementId) {
                if (this.unlockedAchievements.includes(achievementId)) {
                    return;
                }

                this.unlockedAchievements.push(achievementId);
                this.saveProgress();
                const achievement = ACHIEVEMENTS[achievementId];
                this.showToast(achievement);
                this.updateTrophyCount();

                // Grant XP
                if (achievement.xp) {
                    xpSystem.addXP(achievement.xp);
                }

                // Check if all achievements unlocked
                if (this.unlockedAchievements.length === Object.keys(ACHIEVEMENTS).length - 1) {
                    setTimeout(() => this.unlock('unlock_all'), 500);
                }
            }

            showToast(achievement) {
                this.toastQueue.push(achievement);
                if (!this.isShowingToast) {
                    this.processToastQueue();
                }
            }

            processToastQueue() {
                if (this.toastQueue.length === 0) {
                    this.isShowingToast = false;
                    return;
                }

                this.isShowingToast = true;
                const achievement = this.toastQueue.shift();

                // Create toast element
                const toast = document.createElement('div');
                toast.className = 'achievement-toast';
                toast.innerHTML = `
                    <img class="achievement-icon" src="${achievement.icon}" alt="${achievement.title}" onerror="this.style.display='none'">
                    <div class="achievement-content">
                        <div class="achievement-title">Achievement Unlocked! +${achievement.xp} XP</div>
                        <div class="achievement-description"><strong>${achievement.title}</strong> - ${achievement.description}</div>
                    </div>
                `;

                document.body.appendChild(toast);

                // Show animation
                setTimeout(() => toast.classList.add('show'), 100);

                // Hide and remove after 4 seconds
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        document.body.removeChild(toast);
                        this.processToastQueue();
                    }, 500);
                }, 4000);
            }

            updateTrophyCount() {
                const count = this.unlockedAchievements.length;
                const total = Object.keys(ACHIEVEMENTS).length;
                document.getElementById('trophyCount').textContent = `${count}/${total}`;
            }

            setupEventListeners() {
                // Scroll detection (horizontal)
                window.addEventListener('scroll', () => {
                    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                    const windowWidth = window.innerWidth;
                    const documentWidth = document.documentElement.scrollWidth;

                    // Check if scrolled to the end
                    if (scrollLeft + windowWidth >= documentWidth - 100) {
                        this.unlock('scroll_end');
                    }

                    // Check if About Me section is in view
                    const aboutSection = document.querySelector('.aboutme-section');
                    if (aboutSection && !this.hasViewedAbout) {
                        const rect = aboutSection.getBoundingClientRect();
                        const isInView = rect.left < windowWidth && rect.right > 0;

                        if (isInView) {
                            // Start timer if not already started
                            if (!this.aboutMeTimer) {
                                this.aboutMeTimer = setTimeout(() => {
                                    this.unlock('read_about');
                                    this.hasViewedAbout = true;
                                }, 5000); // 5 seconds
                            }
                        } else {
                            // Cancel timer if user scrolled away
                            if (this.aboutMeTimer) {
                                clearTimeout(this.aboutMeTimer);
                                this.aboutMeTimer = null;
                            }
                        }
                    }

                    // Track which projects are in view (excluding hidden ones)
                    const projectFrames = document.querySelectorAll('.project-item:not([data-hidden="true"])');
                    projectFrames.forEach((project, index) => {
                        const rect = project.getBoundingClientRect();
                        if (rect.left < windowWidth && rect.right > 0) {
                            this.projectsViewed.add(index);
                            if (this.projectsViewed.size === projectFrames.length) {
                                this.unlock('view_all_projects');
                            }
                        }
                    });
                });

                // External link clicks
                document.querySelectorAll('.project-info a').forEach(link => {
                    link.addEventListener('click', () => {
                        this.unlock('external_link');
                    });
                });

                // Project hover tracking (excluding hidden projects)
                document.querySelectorAll('.project-item:not([data-hidden="true"]) .project-frame').forEach((frame, index) => {
                    frame.addEventListener('mouseenter', () => {
                        this.projectsHovered.add(index);
                        if (this.projectsHovered.size >= 3) {
                            this.unlock('hover_master');
                        }
                    });
                });

                // West button click - show all achievements
                document.getElementById('btnWest').addEventListener('click', () => {
                    this.showAchievementList();
                });
            }

            showAchievementList() {
                const modal = document.getElementById('achievementModal');
                const grid = document.getElementById('achievementGrid');
                const progress = document.getElementById('modalProgress');

                // Update progress text
                const total = Object.keys(ACHIEVEMENTS).length;
                const count = this.unlockedAchievements.length;
                progress.textContent = `${count}/${total} Unlocked`;

                // Clear and populate grid
                grid.innerHTML = '';
                Object.values(ACHIEVEMENTS).forEach(ach => {
                    const unlocked = this.unlockedAchievements.includes(ach.id);
                    const card = document.createElement('div');
                    card.className = `achievement-card ${unlocked ? 'unlocked' : 'locked'}`;
                    card.innerHTML = `
                        <img class="achievement-card-icon" src="${ach.icon}" alt="${ach.title}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2264%22 height=%2264%22%3E%3Crect width=%2264%22 height=%2264%22 fill=%22%23666%22 rx=%228%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 font-size=%2224%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22%3E%3F%3C/text%3E%3C/svg%3E'">
                        <div class="achievement-card-content">
                            <div class="achievement-card-title">
                                ${ach.title}
                            </div>
                            <div class="achievement-card-description">${ach.description}</div>
                        </div>
                    `;
                    grid.appendChild(card);
                });

                // Show modal
                modal.classList.add('show');
            }

            hideAchievementList() {
                const modal = document.getElementById('achievementModal');
                modal.classList.remove('show');
            }
        }

        // Initialize achievement system
        const achievementManager = new AchievementManager();

        // Modal close functionality
        document.getElementById('closeModal').addEventListener('click', () => {
            achievementManager.hideAchievementList();
        });

        // Close modal when clicking outside
        document.getElementById('achievementModal').addEventListener('click', (e) => {
            if (e.target.id === 'achievementModal') {
                achievementManager.hideAchievementList();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                achievementManager.hideAchievementList();
            }
        });

        // Dev Console System
        class DevConsole {
            constructor() {
                this.console = document.getElementById('devConsole');
                this.output = document.getElementById('consoleOutput');
                this.input = document.getElementById('consoleInput');
                this.isActive = false;
                this.konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
                this.konamiIndex = 0;
                this.hiddenProjectsVisible = false;

                this.commands = {
                    'help': () => this.showHelp(),
                    'ad_testtoast': () => this.testToast(),
                    'ad_showhiddenprojects': () => this.showHiddenProjects(),
                    'clear': () => this.clearOutput(),
                    'close': () => this.toggle()
                };

                this.init();
            }

            init() {
                // Konami code detection
                document.addEventListener('keydown', (e) => {
                    if (e.key === this.konamiCode[this.konamiIndex]) {
                        this.konamiIndex++;
                        if (this.konamiIndex === this.konamiCode.length) {
                            this.activate();
                            this.konamiIndex = 0;
                        }
                    } else {
                        this.konamiIndex = 0;
                    }
                });

                // Console input handling
                this.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const command = this.input.value.trim();
                        if (command) {
                            this.executeCommand(command);
                            this.input.value = '';
                        }
                    }
                });

                // Close button
                document.getElementById('closeConsole').addEventListener('click', () => {
                    this.toggle();
                });

                // Focus input when console opens
                this.console.addEventListener('transitionend', () => {
                    if (this.isActive) {
                        this.input.focus();
                    }
                });
            }

            activate() {
                this.addMessage('Konami Code Activated! Developer Console Unlocked.', 'success');
                this.toggle();
            }

            toggle() {
                this.isActive = !this.isActive;
                this.console.classList.toggle('active');
                if (this.isActive) {
                    setTimeout(() => this.input.focus(), 300);
                }
            }

            executeCommand(command) {
                this.addMessage(`> ${command}`, 'command');

                const cmd = command.toLowerCase().trim();
                if (this.commands[cmd]) {
                    this.commands[cmd]();
                } else {
                    this.addMessage(`Unknown command: "${command}". Type 'help' for available commands.`, 'error');
                }

                // Auto-scroll to bottom
                this.output.scrollTop = this.output.scrollHeight;
            }

            addMessage(text, type = 'info') {
                const msg = document.createElement('div');
                msg.className = `console-message console-${type}`;
                msg.textContent = text;
                this.output.appendChild(msg);
                this.output.scrollTop = this.output.scrollHeight;
            }

            showHelp() {
                this.addMessage('Available Commands:', 'info');
                this.addMessage('  help - Show this help message', 'info');
                this.addMessage('  ad_testtoast - Test achievement toast notification', 'info');
                this.addMessage('  ad_showhiddenprojects - Toggle hidden projects visibility', 'info');
                this.addMessage('  clear - Clear console output', 'info');
                this.addMessage('  close - Close the console', 'info');
            }

            testToast() {
                const testAchievement = {
                    id: 'test',
                    title: 'Test Achievement',
                    description: 'This is a test notification from the dev console',
                    icon: 'images/achievements/placeholder.svg',
                    xp: 25
                };
                achievementManager.showToast(testAchievement);
                this.addMessage('Test toast notification triggered.', 'success');
            }

            showHiddenProjects() {
                this.hiddenProjectsVisible = !this.hiddenProjectsVisible;
                const hiddenProjects = document.querySelectorAll('.project-item[data-hidden="true"]');

                hiddenProjects.forEach(project => {
                    if (this.hiddenProjectsVisible) {
                        project.style.display = 'grid';
                    } else {
                        project.style.display = 'none';
                    }
                });

                if (hiddenProjects.length === 0) {
                    this.addMessage('No hidden projects found.', 'warning');
                } else {
                    const state = this.hiddenProjectsVisible ? 'shown' : 'hidden';
                    this.addMessage(`Hidden projects ${state} (${hiddenProjects.length} project${hiddenProjects.length > 1 ? 's' : ''}).`, 'success');
                }
            }

            clearOutput() {
                this.output.innerHTML = '';
                this.addMessage('Console cleared.', 'system');
            }
        }

        // Initialize dev console
        const devConsole = new DevConsole();

        // XP System
        class XPSystem {
            constructor() {
                this.xpBarFill = document.getElementById('xpBarFill');
                this.xpBarText = document.getElementById('xpBarText');
                this.xpLevel = document.getElementById('xpLevel');
                this.levelUpNotification = document.getElementById('levelUpNotification');
                this.levelUpNumber = document.getElementById('levelUpNumber');
                this.canvas = document.getElementById('particleCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.currentLevel = 1;
                this.currentXP = 0;
                this.particles = [];

                this.loadProgress();
                this.setupCanvas();
                this.init();
            }

            init() {
                window.addEventListener('resize', () => this.setupCanvas());
                this.updateDisplay();
                this.animate();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            // Exponential XP requirements: level 1 = 50 XP, each level requires 1.5x more
            getXPForLevel(level) {
                return Math.floor(50 * Math.pow(1.5, level - 1));
            }

            // Calculate total XP from all unlocked achievements
            calculateXPFromAchievements() {
                let totalXP = 0;
                achievementManager.unlockedAchievements.forEach(achId => {
                    const achievement = ACHIEVEMENTS[achId];
                    if (achievement && achievement.xp) {
                        totalXP += achievement.xp;
                    }
                });
                return totalXP;
            }

            // Initialize XP and level from unlocked achievements
            initializeFromAchievements() {
                let totalXP = this.calculateXPFromAchievements();

                // Calculate level and current XP from total earned XP
                this.currentLevel = 1;
                this.currentXP = totalXP;

                // Process level ups (consume XP for each level gained)
                while (this.currentXP >= this.getXPForLevel(this.currentLevel)) {
                    this.currentXP -= this.getXPForLevel(this.currentLevel);
                    this.currentLevel++;
                }
            }

            loadProgress() {
                // XP is now calculated from achievements, not stored separately
                this.initializeFromAchievements();
            }

            saveProgress() {
                // No longer saving XP - it's calculated from achievements
            }

            addXP(amount) {
                this.currentXP += amount;

                // Check for level ups
                let leveledUp = false;
                while (this.currentXP >= this.getXPForLevel(this.currentLevel)) {
                    this.currentXP -= this.getXPForLevel(this.currentLevel);
                    this.currentLevel++;
                    leveledUp = true;
                }

                if (leveledUp) {
                    this.levelUp();
                }

                this.saveProgress();
                this.updateDisplay();
            }

            updateDisplay() {
                const xpNeeded = this.getXPForLevel(this.currentLevel);
                const progress = (this.currentXP / xpNeeded) * 100;

                this.xpBarFill.style.width = progress + '%';
                this.xpBarText.textContent = `${this.currentXP}/${xpNeeded}`;
                this.xpLevel.textContent = this.currentLevel;
            }

            levelUp() {
                // Show level up notification
                this.levelUpNumber.textContent = this.currentLevel;
                this.levelUpNotification.classList.add('show');

                // Create particles
                this.createLevelUpParticles();

                // Hide notification after 2 seconds
                setTimeout(() => {
                    this.levelUpNotification.classList.remove('show');
                }, 2000);
            }

            createLevelUpParticles() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const particleCount = 50;

                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const velocity = 2 + Math.random() * 3;

                    this.particles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * velocity,
                        vy: Math.sin(angle) * velocity,
                        life: 1,
                        decay: 0.015 + Math.random() * 0.01,
                        size: 3 + Math.random() * 4,
                        color: this.getRandomColor()
                    });
                }
            }

            getRandomColor() {
                const colors = ['#FFB014', '#FFC04D', '#FFD700', '#FFA500'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Update and draw particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    // Update particle
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; // Gravity
                    p.life -= p.decay;

                    // Remove dead particles
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }

                    // Draw particle
                    this.ctx.save();
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }

                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize XP system
        const xpSystem = new XPSystem();

        // Minimap System
        class MinimapSystem {
            constructor() {
                this.minimap = document.getElementById('minimap');
                this.viewportBox = document.getElementById('minimapViewportBox');
                this.leftBoundary = document.querySelector('.minimap-boundary-left');
                this.timeCycle = document.getElementById('timeCycle');
                this.init();
            }

            init() {
                // Update time rotation
                this.updateTimeRotation();
                setInterval(() => this.updateTimeRotation(), 60000); // Update every minute

                // Update viewport box position on scroll
                window.addEventListener('scroll', () => this.updateViewportPosition());
                window.addEventListener('resize', () => this.updateViewportPosition());
                this.updateViewportPosition();
            }

            updateTimeRotation() {
                const now = new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const totalMinutes = hours * 60 + minutes;

                // Adjust so 6am is 0deg (start of day), 6pm is 180deg (start of night)
                const adjustedMinutes = (totalMinutes - 360 + 1440) % 1440; // Subtract 6am (360 min) and wrap
                const rotation = (adjustedMinutes / 1440) * 360;

                // Rotate counter-clockwise (negate the rotation)
                this.timeCycle.style.transform = `rotate(-${rotation}deg)`;
            }

            updateViewportPosition() {
                const scrollPercentage = window.scrollX / (document.documentElement.scrollWidth - window.innerWidth);

                // Get actual dimensions from DOM for responsive support
                const minimapWidth = this.minimap.offsetWidth;
                const viewportBoxWidth = this.viewportBox.offsetWidth;
                const leftBoundaryPos = this.leftBoundary.offsetLeft; // Read from DOM for responsiveness
                const rightBoundaryOffset = 5; // Right boundary from right edge
                const boundaryWidth = 2; // Boundary line width
                const leftGap = 4; // Gap on left side between viewport box and left boundary
                const rightGap = 6; // Gap on right side between viewport box and right boundary

                // Calculate travel range with asymmetric gaps (4px left, 6px right)
                // Left: boundary position + 4px gap
                // Right: boundary at (width - 5 - 2), box right edge stops 6px before at (width - 5 - 2 - 6)
                //        so box left position is (width - 13 - boxWidth)
                const minLeft = leftBoundaryPos + leftGap;
                const maxLeft = minimapWidth - rightBoundaryOffset - boundaryWidth - rightGap - viewportBoxWidth;
                const travelRange = maxLeft - minLeft;

                // Calculate left position based on scroll percentage
                const leftPosition = minLeft + (scrollPercentage * travelRange);

                this.viewportBox.style.left = `${leftPosition}px`;
            }
        }

        // Initialize minimap
        const minimapSystem = new MinimapSystem();

        // Horizontal Scroll System - Convert vertical wheel to horizontal scroll
        window.addEventListener('wheel', (e) => {
            // Prevent default vertical scroll
            if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                e.preventDefault();
                // Convert vertical scroll to horizontal
                window.scrollBy({
                    left: e.deltaY,
                    behavior: 'auto'
                });
            }
        }, { passive: false });

        // Mobile touch scroll - disable vertical, enable horizontal
        let touchStartY = 0;
        let touchStartX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            const touchDeltaY = Math.abs(e.touches[0].clientY - touchStartY);
            const touchDeltaX = Math.abs(e.touches[0].clientX - touchStartX);

            // If vertical movement is greater than horizontal, prevent it
            if (touchDeltaY > touchDeltaX) {
                e.preventDefault();
            }
        }, { passive: false });

        // Custom Scrollbar System
        function updateCustomScrollbar() {
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollWidth = document.documentElement.scrollWidth - window.innerWidth;
            const scrollPercentage = (scrollLeft / scrollWidth) * 100;

            const scrollbarThumb = document.getElementById('scrollbarThumb');
            if (scrollbarThumb) {
                scrollbarThumb.style.width = scrollPercentage + '%';
            }
        }

        window.addEventListener('scroll', updateCustomScrollbar);
        window.addEventListener('resize', updateCustomScrollbar);
        updateCustomScrollbar();

        // Controller buttons functionality
        const btnNorth = document.getElementById('btnNorth');
        const themeBadge = document.getElementById('themeBadge');
        const body = document.body;

        // Function to update theme badge
        function updateThemeBadge() {
            if (body.classList.contains('light-mode')) {
                themeBadge.textContent = 'Dark';
            } else {
                themeBadge.textContent = 'Light';
            }
        }

        // Initialize theme badge
        updateThemeBadge();

        // North button - Theme toggle
        btnNorth.addEventListener('click', () => {
            body.classList.toggle('light-mode');
            updateThemeBadge();

            if (body.classList.contains('light-mode')) {
                achievementManager.unlock('light_mode');
            } else {
                achievementManager.unlock('dark_mode');
            }
        });

        // D-Pad functionality - dispatch keyboard events for Konami code
        function dispatchKeyEvent(key) {
            const event = new KeyboardEvent('keydown', {
                key: key,
                code: key,
                bubbles: true,
                cancelable: true
            });
            document.dispatchEvent(event);
        }

        document.getElementById('dpadUp').addEventListener('click', () => {
            dispatchKeyEvent('ArrowUp');
        });

        document.getElementById('dpadDown').addEventListener('click', () => {
            dispatchKeyEvent('ArrowDown');
        });

        // D-pad left/right continuous scroll when held down
        let scrollInterval = null;
        const scrollSpeed = 20; // Interval in milliseconds (faster = smoother)
        const scrollAmount = 8; // Pixels per interval tick (20ms * 8px = 400px/second)

        function startContinuousScroll(direction) {
            // Clear any existing interval
            if (scrollInterval) {
                clearInterval(scrollInterval);
            }

            // Immediate first scroll
            window.scrollBy({
                left: direction === 'left' ? -scrollAmount : scrollAmount,
                behavior: 'auto' // Use auto for continuous scrolling
            });

            // Start continuous scrolling
            scrollInterval = setInterval(() => {
                window.scrollBy({
                    left: direction === 'left' ? -scrollAmount : scrollAmount,
                    behavior: 'auto'
                });
            }, scrollSpeed);
        }

        function stopContinuousScroll() {
            if (scrollInterval) {
                clearInterval(scrollInterval);
                scrollInterval = null;
            }
        }

        // Left button continuous scroll
        const dpadLeft = document.getElementById('dpadLeft');
        dpadLeft.addEventListener('mousedown', () => startContinuousScroll('left'));
        dpadLeft.addEventListener('mouseup', stopContinuousScroll);
        dpadLeft.addEventListener('mouseleave', stopContinuousScroll);
        dpadLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startContinuousScroll('left');
        });
        dpadLeft.addEventListener('touchend', stopContinuousScroll);
        dpadLeft.addEventListener('touchcancel', stopContinuousScroll);

        // Right button continuous scroll
        const dpadRight = document.getElementById('dpadRight');
        dpadRight.addEventListener('mousedown', () => startContinuousScroll('right'));
        dpadRight.addEventListener('mouseup', stopContinuousScroll);
        dpadRight.addEventListener('mouseleave', stopContinuousScroll);
        dpadRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startContinuousScroll('right');
        });
        dpadRight.addEventListener('touchend', stopContinuousScroll);
        dpadRight.addEventListener('touchcancel', stopContinuousScroll);

        // Keep click handlers for Konami code compatibility
        document.getElementById('dpadLeft').addEventListener('click', () => {
            dispatchKeyEvent('ArrowLeft');
        });

        document.getElementById('dpadRight').addEventListener('click', () => {
            dispatchKeyEvent('ArrowRight');
        });

        // East button (B) and South button (A) - dispatch keyboard events
        document.getElementById('btnEast').addEventListener('click', () => {
            dispatchKeyEvent('b');
        });

        document.getElementById('btnSouth').addEventListener('click', () => {
            dispatchKeyEvent('a');
        });

        // Keyboard arrow key scrolling with held-down support
        let keyScrollInterval = null;
        let currentScrollKey = null;

        document.addEventListener('keydown', (e) => {
            // Don't scroll if user is typing in the dev console
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // Only respond to real keyboard events, not dispatched events from D-pad clicks
            if (!e.isTrusted) {
                return;
            }

            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();

                // If already scrolling with this key, don't start again
                if (currentScrollKey === e.key) {
                    return;
                }

                // Stop any existing scroll
                if (keyScrollInterval) {
                    clearInterval(keyScrollInterval);
                }

                currentScrollKey = e.key;
                const direction = e.key === 'ArrowLeft' ? -1 : 1;
                const keyScrollAmount = 8; // Pixels per interval tick (20ms * 8px = 400px/second)

                // Immediate first scroll
                window.scrollBy({
                    left: direction * keyScrollAmount,
                    behavior: 'auto'
                });

                // Start continuous scrolling
                keyScrollInterval = setInterval(() => {
                    window.scrollBy({
                        left: direction * keyScrollAmount,
                        behavior: 'auto'
                    });
                }, 20);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (keyScrollInterval) {
                    clearInterval(keyScrollInterval);
                    keyScrollInterval = null;
                    currentScrollKey = null;
                }
            }
        });

        // Stop all scrolling if window loses focus
        window.addEventListener('blur', () => {
            stopContinuousScroll();
            if (keyScrollInterval) {
                clearInterval(keyScrollInterval);
                keyScrollInterval = null;
                currentScrollKey = null;
            }
        });

        // Initialize project frames with static images
        const projectFrames = document.querySelectorAll('.project-frame');
        
        projectFrames.forEach(frame => {
            frame.style.backgroundImage = `url('${frame.dataset.src}')`;
        });

        // Auto-play GIF for project closest to center
        let currentActiveFrame = null;
        let changeTimeout = null;

        function updateActiveProject() {
            const viewportCenter = window.innerWidth / 2;
            let closestFrame = null;
            let smallestDistance = Infinity;

            projectFrames.forEach(frame => {
                if (!frame.dataset.hover) return; // Skip if no GIF available

                const rect = frame.getBoundingClientRect();
                const frameCenter = rect.left + rect.width / 2;
                const distance = Math.abs(frameCenter - viewportCenter);

                if (distance < smallestDistance) {
                    smallestDistance = distance;
                    closestFrame = frame;
                }
            });

            // Update frames with 1 second delay
            if (closestFrame !== currentActiveFrame) {
                // Clear any pending change
                if (changeTimeout) {
                    clearTimeout(changeTimeout);
                }

                // Wait 1 second before changing
                changeTimeout = setTimeout(() => {
                    // Stop previous GIF
                    if (currentActiveFrame && currentActiveFrame.dataset.hover) {
                        currentActiveFrame.style.backgroundImage = `url('${currentActiveFrame.dataset.src}')`;
                    }

                    // Play new GIF
                    if (closestFrame && closestFrame.dataset.hover) {
                        closestFrame.style.backgroundImage = `url('${closestFrame.dataset.hover}')`;
                    }

                    currentActiveFrame = closestFrame;
                }, 500);
            }
        }

        // Throttle scroll events for better performance
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            if (scrollTimeout) {
                window.cancelAnimationFrame(scrollTimeout);
            }
            scrollTimeout = window.requestAnimationFrame(() => {
                updateActiveProject();
            });
        });

        // Initial check
        updateActiveProject();

        // Manual hover still works
        projectFrames.forEach(frame => {
            frame.addEventListener('mouseenter', () => {
                if(frame.dataset.hover) {
                    frame.style.backgroundImage = `url('${frame.dataset.hover}')`;
                }
            });

            frame.addEventListener('mouseleave', () => {
                // Only reset if this frame is not the currently active one
                if (frame !== currentActiveFrame) {
                    frame.style.backgroundImage = `url('${frame.dataset.src}')`;
                }
            });
        });
    </script>
</body>
</html>